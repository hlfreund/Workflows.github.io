<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Author: Hannah Freund (hfreu002@ucr.edu)" />


<title>Amplicon Analysis Workflow</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

.sourceCode .row {
  width: 100%;
}
.sourceCode {
  overflow-x: auto;
}
.code-folding-btn {
  margin-right: -30px;
}
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>







<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">The Workflows</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Workflows
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="amplicon_workflow.html">
        <span class="fal fa-bacteria"></span>
         
        Amplicon Sequence Worfklow
      </a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Amplicon Analysis Workflow</h1>
<h4 class="author">Author: Hannah Freund (<a href="mailto:hfreu002@ucr.edu" class="email">hfreu002@ucr.edu</a>)</h4>
<h4 class="date">Last update: 12 December, 2021</h4>

</div>


<style type="text/css">
  body{
  font-size: 13pt;
}
</style>
<!--
Render from R:
rmarkdown::render("Amplicon_Workflow.Rmd", clean=TRUE, output_format="html_document")
R

Rendering from the command-line. To render to PDF format, use the argument setting: output_format="pdf_document".
$ Rscript -e "rmarkdown::render('Amplicon_Workflow.Rmd', output_format='html_document', clean=TRUE)"

Add logo:
htmltools::img(src = knitr::image_uri("mylogo.png"), 
               alt = 'logo', 
               style = 'position:absolute; top:0; center:0; padding:10px;')
-->
<div id="background" class="section level1">
<h1><span class="header-section-number">1</span> Background</h1>
<p>This is a tutorial on how to process your 16S ITS1/ITS2 amplicon sequences and identify the taxonomic identification of the ASVs (i.e., amplicon sequence variants, also known as zOTUs for zero OTUs or ESVs for exact sequence variants) in your sequence data.</p>
<p>To create this tutorial, I have assembled scripts I’ve used to analyze 16S data provided by Dr. Emma Aronson’s lab. The data I am working with to create this workflow comes from a project that examined soil microbial community composition in Mount Saint Helens. The target region was the V4 region within the 16S gene, and sequencing was performed with an Illumina MiSeq (2x300).</p>
<p>You can find all of the scripts used in this workflow in this <a href="https://github.com/hlfreund/Amplicon_Sequencing_Worfklow">repository</a>.</p>
<p>This tutorial would not have been possible without <a href="https://callahanlab.cvm.ncsu.edu/">Dr. Benjamin Callahan’s</a> <code>DADA2</code> <a href="https://github.com/benjjneb/dada2">program</a> <span class="citation">(Callahan et al. 2016)</span> and <a href="https://benjjneb.github.io/dada2/tutorial.html">tutorials</a>. Additionally, I would like to especially thank <a href="https://astrobiomike.github.io/research/">Dr. Mike Lee</a> for his guidance, his patience, and his Happy Belly Bioinformatics tutorial called <a href="https://astrobiomike.github.io/amplicon/dada2_workflow_ex#removing-likely-contaminants"><strong>Amplicon Analysis</strong></a> tutorial <span class="citation">(Lee 2019)</span>.</p>
<div id="considerations-before-you-begin" class="section level2">
<h2><span class="header-section-number">1.1</span> Considerations before you begin</h2>
<p>I was able to analyze these sequences on a High Performance Computing cluster (HPCC) that uses a Slurm scheduler. The minimum amount of total memory I used (not per CPU, but overall) for each step in this workflow (i.e., each step as a separate ‘job’ via Slurm) was 400GB. Having enough memory is essential to running most of these programs, so please keep this in mind before embarking on this workflow!</p>
<p>These steps are also time consuming depending on your memory constraints, so do not be concerned if this process takes a while. If you plan to run through multiple steps in the workflow in one sitting, then I suggest loading <strong>tmux</strong> before you run your scripts. Here is a handy <a href="https://tmuxcheatsheet.com/">tmux cheat sheet</a> that I refer to often. For more information on what tmux is and how to utilize it, check this <a href="https://thoughtbot.com/blog/a-tmux-crash-course">tmux crash course</a> by Josh Clayton.</p>
<p>I also suggest exploring a program called <strong>neovim</strong> (aka nvim) that allows you to use Vim (a text editor) to edit R code and run the code simultaneously. Though nvim is not necessary to run through this workflow, I find that it makes my life a bit easier when running through the <code>DADA2</code> portion of the workflow. I will get more into the usage of nvim once we get to the <code>DADA2</code> step(s), but for more information please view the <a href="https://github.com/jalvesaq/Nvim-R">Neovim Github</a> as well as its <a href="https://github.com/jamespeapen/Nvim-R/wiki#overview">documentation</a>. You can also find a helpful nvim tutorial <a href="https://girke.bioinformatics.ucr.edu/GEN242/tutorials/linux/linux/#nvim-r-tmux-essentials">here</a> created by Dr. Thomas Girke from UC Riverside.</p>
<p>Additionally, you will need to change your path to each of these programs depending on where they are stored in your computer or HPCC. If you are running these steps locally (which, if you are, then you have one badass computer!), then you can skip the module loading lines in each step – loading modules is specifically for running these scripts on a HPCC that uses a Slurm Workload Manager.</p>
</div>
<div id="submitting-scripts-as-jobs-with-slurm" class="section level2">
<h2><span class="header-section-number">1.2</span> Submitting Scripts as Jobs with Slurm</h2>
<p>If you are unsure as to how to set up the script for submitting on your HPCC, check the code chunk below. This is the information I use when submitting a job to our Slurm system. Again, this is specifically for a system that uses the Slurm scheduler. For more information on what the arguments mean and how to set up your job submissions, please refer to this handy <a href="https://slurm.schedmd.com/pdfs/summary.pdf">cheatsheet</a> made by Slurm.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">#!/bin/bash -l</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">#SBATCH --nodes=1</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">#SBATCH --ntasks=1</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co">#SBATCH --cpus-per-task=4 # must match the # of threads if program allows threading (-t #)</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co">##SBATCH --mem-per-cpu=500G # memory per cpu - * if threading, do not let this line run (use ##). Cannot ask for too much memory per cpu!</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="co">#SBATCH --mem=500GB # overall memory - if you&#39;re threading, keep this line</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="co">#SBATCH --time=1-00:00:00     # time requested; this example is 1 day, 0 hrs</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="co">#SBATCH --output=name_of_log_file_6.27.21.stdout # name of your log file</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="co">#SBATCH --mail-user=email_address@gmail.com # your email address </span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="co">#SBATCH --mail-type=ALL # will send you email updates when job starts and ends (and if it runs successfully or not)</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="co">#SBATCH --job-name=&quot;Name of Job 1/1/21&quot; # name of your job for Slurm</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="co">#SBATCH -p node_name_here # partition node name</span></a></code></pre></div>
<p>When I don’t know exactly what a program’s output will look like, I will run the program via an interactive job on the HPCC. I also suggest running programs interactively if the program requires multiple lines of code to run, and you want to make sure each step has the correct input (whether it be a file, an object, or the output of a previous step in the code). For some more information on interactive jobs in a Slurm system, check out this <a href="https://yunmingzhang.wordpress.com/2015/06/29/how-to-use-srun-to-get-an-interactive-node/">blog post</a> by Yunming Zhang. This is how I set up an interactive job on the HPCC (that uses Slurm).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">srun</span> -p node_name_here --mem=500gb --time=1-00:00:00 --pty bash -l</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co"># -p = partition</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co"># --mem = overall memory being requested, not memory per CPU</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co"># --time = overall time requested; 1 day, 0 hrs</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co"># -–pty = gives you a pseudo terminal that runs bash</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co"># bash -l = setting bash as language</span></a></code></pre></div>
</div>
<div id="a-bash-scripting-tip-for-before-we-start" class="section level2">
<h2><span class="header-section-number">1.3</span> A bash scripting tip for before we start</h2>
<p>I wanted to share a bit of code that you will see being implemented in every script throughout the tutorial. This little bit of code will help you pull out the sample names from your files, allowing you easily run through your files while also keeping track of which samples those files belong to.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">for</span> <span class="ex">FILE</span> in path/*.fastq<span class="kw">;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="va">f=$(</span><span class="fu">basename</span> <span class="va">$FILE)</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="va">SAMPLE=${f%</span>.fastq*<span class="va">}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="bu">echo</span> <span class="va">$SAMPLE</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">done</span></a></code></pre></div>
<p>Here I am using using a for loop to loop through each fastq files in a specific directory. In each iteration of the loop, an <code>$f</code> variable is created, which uses the <code>basename</code> function to get the file name of the <code>$FILE</code> variable. Then <code>$SAMPLE</code> is created by using <code>%</code> to remove the <code>.fastq</code> extension and everything that follows, keeping only the file name (minus the extension) and calling that <code>$SAMPLE</code>. Then we can use the <code>$SAMPLE</code> variable to substitute the file names, which come in handy for running these scripts over multiple samples at one time. This concept should become clearer as we move through the workflow. If you’d like more information on string substitution (i.e., using <code>%</code> to remove parts of a string), please see this helpful <a href="https://tldp.org/LDP/abs/html/string-manipulation.html">link</a>.</p>
</div>
</div>
<div id="sample-pre-processing" class="section level1">
<h1><span class="header-section-number">2</span> Sample pre-processing</h1>
<div id="demultiplex-your-samples" class="section level2">
<h2><span class="header-section-number">2.1</span> Demultiplex your samples</h2>
<p>When preparing sequencing libraries, we typically multiplex our samples. This means that during library preparation, we’ve attached barcodes to our sequences that help us trace the sample that these sequences came from. This allows us to pool multiple libraries together in one sequencing run. After sequencing, the sequences are <em>demultiplexed</em>, meaning the individual sequences are separated out by sample into individual FASTQ files.</p>
<p>Typically your samples will be returned to you already demultiplexed. However, if your samples are still pooled into one large FASTQ file, do not panic! You can follow the <a href="https://astrobiomike.github.io/amplicon/demultiplexing"><strong>demultiplexing tutorial</strong></a> by <a href="https://astrobiomike.github.io/research/">Dr. Mike Lee</a> which utilizes the <a href="https://github.com/najoshi/sabre"><code>sabre</code> tool</a>. Or, you can use <code>bcl2fastq2</code> by Illumina (more information <a href="https://support.illumina.com/content/dam/illumina-support/documents/documentation/software_documentation/bcl2fastq/bcl2fastq2-v2-20-software-guide-15051736-03.pdf">here</a>).</p>
</div>
<div id="sequence-quality-and-where-to-trim" class="section level2">
<h2><span class="header-section-number">2.2</span> Sequence Quality and Where to Trim</h2>
<div id="check-the-quality-of-your-sequences-with-fastqc" class="section level3">
<h3><span class="header-section-number">2.2.1</span> Check the quality of your sequences with <code>FastQC</code></h3>
<p>It’s always a good idea to check the quality of your sequences before you start your analysis, regardless of the type of sequences they are (metagenomes, RNA-seq data, etc). <code>FastQC</code> <span class="citation">(Andrews, n.d.)</span> provides a comprehensive report on the quality of your sequences and is helpful for the following: identifying primers or adapters still attached to your sequences; determining the quality of your reverse reads; etc. You can also use the FastQC reports to determine if you should attempt to merge your forward and reverse reads, or just proceed with only the forward reads.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># Set &quot;today&quot; variable to be date to help keep track of file generation</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co"># * I always create a &#39;today&#39; variable just in case I want to keep track of exactly when I created certain files and directories</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="va">today=$(</span><span class="fu">date</span> <span class="st">&quot;+%m.%d.%y&quot;</span><span class="va">)</span> <span class="co"># date is the command to get today&#39;s date, and the &quot;+%m_%d_%y&quot; will print it in month_day_year format</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co"># create a directory to store your FastQC results in</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./FastQC_Results<span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="fu">mkdir</span> FastQC_Results</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="co"># create directory within results directory for 16S FastQC Results</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./FastQC_Results/16S_FastQC<span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="fu">mkdir</span> FastQC_Results/16S_FastQC</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="co"># create directory within results directory for ITS2 (or ITS1) FastQC Results</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./FastQC_Results/ITS2_FastQC<span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    <span class="fu">mkdir</span> FastQC_Results/ITS2_FastQC</a>
<a class="sourceLine" id="cb4-18" data-line-number="18"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"><span class="co"># loop through each 16S fastq.gz file and run through FastQC</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="kw">for</span> <span class="ex">FILE</span> in 16S_Seqs/*.fastq.gz<span class="kw">;</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"><span class="kw">do</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">    <span class="co"># extract out just the sample name from the file name</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">    <span class="va">f=$(</span><span class="fu">basename</span> <span class="va">$FILE)</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    <span class="va">SAMPLE=${f%</span>.fastq*<span class="va">}</span> <span class="co">#string manipulation to drop .fastq and everything that comes after</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    </a>
<a class="sourceLine" id="cb4-27" data-line-number="27">    <span class="ex">fastqc</span> <span class="va">$FILE</span> --outdir=./FastQC_Results/16S_FastQC</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">    </a>
<a class="sourceLine" id="cb4-29" data-line-number="29"><span class="kw">done</span></a>
<a class="sourceLine" id="cb4-30" data-line-number="30"></a>
<a class="sourceLine" id="cb4-31" data-line-number="31"><span class="co"># loop through each ITS2 fastq.gz file and run through FastQC</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32"><span class="kw">for</span> <span class="ex">FILE</span> in ITS2_Seqs/*.fastq.gz<span class="kw">;</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33"><span class="kw">do</span></a>
<a class="sourceLine" id="cb4-34" data-line-number="34">    <span class="va">f=$(</span><span class="fu">basename</span> <span class="va">$FILE)</span></a>
<a class="sourceLine" id="cb4-35" data-line-number="35">    <span class="va">SAMPLE=${f%</span>.fastq*<span class="va">}</span></a>
<a class="sourceLine" id="cb4-36" data-line-number="36">    <span class="ex">fastqc</span> <span class="va">$FILE</span> --outdir=./FastQC_Results/ITS2_FastQC</a>
<a class="sourceLine" id="cb4-37" data-line-number="37">    </a>
<a class="sourceLine" id="cb4-38" data-line-number="38"><span class="kw">done</span></a></code></pre></div>
<p>FastQC will return a report assessing the per base and per sequence quality of your sequences, as well as the GC and N (i.e., unidentified base) content across your sequences, the distribution of your sequence lengths, and whether or not adapters are still attached to your sequences. The second tab of the report details the per base sequence quality across all of your sequences. The per base quality score (<strong>Q score</strong>), also known as a <strong>Phred score</strong>, is the estimated probability that the base call is wrong. The following equation is used for calculating the Q score: <span class="math display">\[
Q = -10log_{10}E
\]</span> Here, E is the estimated probability of the base call being wrong. The higher the Q score, the smaller the probability of a base call error. A quality score of 30 (Q30) means that the probability of an incorrect base call is 1 in 1000, and that the base call accuracy (1 - probability of incorrect base call) is 99.9%. For more information on quality scores, please see this info from <a href="https://www.illumina.com/science/technology/next-generation-sequencing/plan-experiments/quality-scores.html">Illumina</a>.</p>
<p>Below is an example of the “per base sequence quality” portion of the report. This portion of the report helps me to determine where I should trim my sequences as I move forward with the analysis. This part of the report can also give you a sense on whether there was an error in your sequencing run. For example, if the average quality score (i.e., the blue line in the report) across all of the bases dips below 30 for half of the sequence length in all of my samples, that could indicate that there was an error with the sequencing run itself.</p>
<center>
<img src="amplicon_workflow/fastqc_base_seq_qual_plot.png" />
</center>
<div align="center">
Figure 1: Per Base Quality Scores from FastQC Report
</div>
<p></br></p>
<p>Another useful piece of the FastQC report is the adapter content tab, which is the very last tab in the report. This portion of the report tells us the percentage of reads that have adapter sequences at specific base positions along the reads. The following snapshot from a FastQC report shows that the Small RNA 3’ adapter sequence is found in ~2% of the sequences starting at around the 160th base. We can use this information to then decide exactly which adapter sequences to cut from our samples in the trimming step.</p>
<center>
<img src="amplicon_workflow/fastqc_adapter_content.png" />
</center>
<div align="center">
Figure 2: Frequency of Adapter Sequences from FastQC Report
</div>
<p></br></p>
<p>For more on how to interpret FastQC reports, please check out this helpful <a href="https://rtsf.natsci.msu.edu/genomics/tech-notes/fastqc-tutorial-and-faq/">FastQC tutorial</a> from Michigan State University.</p>
</div>
<div id="expected-error-filtering-of-sequences-with-eestats" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Expected Error Filtering of Sequences with <code>eestats</code></h3>
<p>The <code>eestats2</code> program <span class="citation">(Edgar and Flyvbjerg 2015)</span> creates a report detailing the percentage of reads that will pass through an expected error filter when the reads are at different lengths. Specifically the program will determine how many reads at each specific length (i.e., 50 bp, 100 bp, 150 bp, etc.) have good enough quality to surpass the three expected error thresholds: 0.5%, 1%, and 2%.</p>
<p>Before you run the <code>eestats</code> program, be sure to <em>gunzip</em> (aka decompress) your fastq.gz files! You can do that by running the following command: <code>gunzip /path/to/*.fastq.gz</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># Create directory to store eestats results</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./EEstats_Results<span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="fu">mkdir</span> EEstats_Results</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="co"># Create specific directory within eestats results for 16S eestats results</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./EEstats_Results/16S_EEstats<span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="fu">mkdir</span> EEstats_Results/16S_EEstats</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="co"># Create specific directory within eestats results for ITS2 (or ITS1) eestats results</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./EEstats_Results/ITS2_EEstats<span class="kw"> ]]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="fu">mkdir</span> EEstats_Results/ITS2_EEstats</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="co"># Run eestats2 in loop with 16S fastq files</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17"><span class="kw">for</span> <span class="ex">FILE</span> in 16S_Seqs/*.fastq<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="kw">do</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">    <span class="va">f=$(</span><span class="fu">basename</span> <span class="va">$FILE)</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="va">SAMPLE=${f%</span>.fastq*<span class="va">}</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">    </a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    <span class="ex">usearch</span> -fastq_eestats2 <span class="va">$FILE</span> -output <span class="va">${SAMPLE}</span>_eestats2.txt</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">    <span class="co"># move results to EEstats_Results directory</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    <span class="fu">mv</span> <span class="va">${SAMPLE}</span>_eestats2.txt EEstats_Results/16S_EEstats</a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="kw">done</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26"></a>
<a class="sourceLine" id="cb5-27" data-line-number="27"><span class="co"># Run eestats2 in loop with ITS2 fastq files</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="kw">for</span> <span class="ex">FILE</span> in ITS2_Seqs/*.fastq<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29"><span class="kw">do</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    <span class="va">f=$(</span><span class="fu">basename</span> <span class="va">$FILE)</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">    <span class="va">SAMPLE=${f%</span>.fastq*<span class="va">}</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32">    </a>
<a class="sourceLine" id="cb5-33" data-line-number="33">    <span class="ex">usearch</span> -fastq_eestats2 <span class="va">$FILE</span> -output <span class="va">${SAMPLE}</span>_eestats2.txt</a>
<a class="sourceLine" id="cb5-34" data-line-number="34">    <span class="co"># move results to EEstats_Results directory</span></a>
<a class="sourceLine" id="cb5-35" data-line-number="35">    <span class="fu">mv</span> <span class="va">${SAMPLE}</span>_eestats2.txt EEstats_Results/ITS2_EEstats</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">    </a>
<a class="sourceLine" id="cb5-37" data-line-number="37"><span class="kw">done</span></a></code></pre></div>
The following image shows a sample eestats2 report. For this specific sample, the ideal trimming length of the sequences would be around 250 basepairs long. This is because when considering the expected error threshold of 1%, more than 80.8% of the sequence pass this threshold. Though the 300 bp length also allows high rentention of reads, we know that the per base quality of this sample drops as we approach the 300 bp position. Thus, it seems like trimming these sequences to 250 bps would be ideal moving forward.
<center>
<img src="amplicon_workflow/eestats_example_report.png" />
</center>
<div align="center">
Figure 3: eestats Report Example
</div>
<p></br> For more information on the <code>eestats2</code> programs by <a href="https://www.drive5.com/usearch/">USEARCH</a>, please read the documentation <a href="https://www.drive5.com/usearch/manual/cmd_fastq_eestats2.html">here</a>.</p>
</div>
</div>
<div id="trim-sequences-and-cut-adapters-primers-etc" class="section level2">
<h2><span class="header-section-number">2.3</span> Trim sequences and cut adapters, primers, etc</h2>
<p>There are plenty of programs out there that can be used for trimming, and the following three are the most popular for amplicon analyses: <a href="https://cutadapt.readthedocs.io/en/stable/"><code>cutadapt</code></a>, <a href="http://www.usadellab.org/cms/?page=trimmomatic"><code>trimmomatic</code></a>, and <a href="https://jgi.doe.gov/data-and-tools/bbtools/bb-tools-user-guide/bbduk-guide/"><code>bbduk</code></a> <span class="citation">(Bushnell, n.d.)</span>. All of these programs are reputable, but I personally like the <code>bbduk</code>, and will use this tool for trimming and adapter removal.</p>
<p>Before I trim my sequences, I refer to the FastQC reports to find out exactly which adapters I should remove from my sequences. For example, when looking at the adapter content portion of the FastQC report above, I can see that the Nextera Transposase Sequence is still present in that particular sample. Thankfully Illumina shares their adapter sequences on their <a href="https://support-docs.illumina.com/SHARE/AdapterSeq/Content/SHARE/AdapterSeq/AdapterSequencesIntro.htm">website</a>, allowing us to easily find common adapters in sequences, like the <a href="https://support-docs.illumina.com/SHARE/AdapterSeq/Content/SHARE/AdapterSeq/Nextera/SequencesNXTILMPrepAndPCR.htm">Nextera Transposase Sequence</a> for example.</p>
<p>I also know that with the sequences I am analyzing, the PCR primers are still attached (FastQC may identify these primers in your report’s Overrepresented Sequences tab, but not necessarily the origin of these sequences). I can either remove these primer sequences using the actual sequence using the (<code>literal=</code>) flag, or I can trim from the right (<code>ftr=</code>) and/or the left (<code>ftl=</code>) of the sequences if I know exactly how long the primer sequences were.</p>
<p>It is recommended to check the overrepresented sequences from the FastQC report to see if there are contaminating sequences present in your data. I suggest taking the most frequent overrepresented sequence and running it through <a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn&amp;BLAST_SPEC=GeoBlast&amp;PAGE_TYPE=BlastSearch">BLASTn</a> if the source of this overrepresented sequence says “No Hit” (meaning that FastQC cannot attribute this sequence to its list of adapter sequences). If the sequence comes up as a contaminant (i.e., a different gene than the amplicon you’re looking at) or adapter/primer of some kind, you can add this to the <code>literal=</code> flag in <code>bbduk</code> to remove the contaminant.</p>
<p>In addition to removing adapter and primer sequences using the the <code>literal=</code> flag, I also include a reference file provided by <code>bbduk</code> (referenced in the <code>ref=</code> flag) that contains all of the Illumina TruSeq adapters. The sequences in the reference file, in addition to the given adapters and primers, will be removed from the sequences. Below the shell script is a description of all of the flags used by <code>bbduk</code> and exactly what they mean.</p>
<p>For more information on the <code>bbduk</code> flags, please see the <code>bbduk</code> <a href="https://jgi.doe.gov/data-and-tools/bbtools/bb-tools-user-guide/bbduk-guide/">documentation</a>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="va">path=</span>/path/to/sequences/here <span class="co"># replace with the path to your files</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./Trimmed_Seqs<span class="kw"> ]]</span>; <span class="kw">then</span> <span class="co"># creating directory to store trimmed sequences in</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="fu">mkdir</span> Trimmed_Seqs</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">if [[</span> <span class="ot">!</span> <span class="ot">-d</span> ./Trimmed_Seqs/16S_Trimmed<span class="kw"> ]]</span>; <span class="kw">then</span> <span class="co"># creating directory for specifically trimmed 16S sequences</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="fu">mkdir</span> Trimmed_Seqs/16S_Trimmed</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="kw">fi</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="kw">for</span> <span class="ex">i</span> in 16S_Seqs/*_R1.fastq<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    <span class="va">f=$(</span><span class="fu">basename</span> <span class="va">$i)</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    <span class="va">SAMPLE=${f%</span>_R*<span class="va">}</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="ex">bbduk.sh</span> -Xmx10g in1=<span class="va">${path}</span>/16S_Seqs/<span class="va">${SAMPLE}</span>_R1.fastq in2=<span class="va">${path}</span>/16S_Seqs/<span class="va">${SAMPLE}</span>_R2.fastq out1=<span class="va">${path}</span>/Trimmed_Seqs/16S_Trimmed/<span class="va">${SAMPLE}</span>_R1_clean.fastq out2=<span class="va">${path}</span>/Trimmed_Seqs/16S_Trimmed/<span class="va">${SAMPLE}</span>_R2_clean.fastq literal=TCGTCGGCAGCGTCAGATGTGTATAAGAGACAG,GTCTCGTGGGCTCGGAGATGTGTATAAGAGACAG ref=/bigdata/aronsonlab/shared/bbmap_resources/adapters.fa rcomp=t ktrim=r k=23 maq=10 minlength=200 mink=11 hdist=1 tpe tbo</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb6-18" data-line-number="18"><span class="kw">done</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19"></a>
<a class="sourceLine" id="cb6-20" data-line-number="20"><span class="co"># ref ---&gt; file provided by bbduk that holds collection of Illumina TruSeq adapters</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21"><span class="co"># literal=(sequence here) ---&gt; literal adapter sequences to remove; &quot;N&quot; represents any base -- in this case, they are indexes within the adapters</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22"><span class="co"># rcomp=t ---&gt; Rcomp looks for kmers and their reverse-complements, rather than just forward kmer, if set to true</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23"><span class="co"># ktrim=r ---&gt; “ktrim=r” is for right-trimming (3′ adapters)</span></a>
<a class="sourceLine" id="cb6-24" data-line-number="24"><span class="co"># k=23 ---&gt; look for kmer that is 23 bp long</span></a>
<a class="sourceLine" id="cb6-25" data-line-number="25"><span class="co"># mink=11 ---&gt; in addition to kmers of x length, look for shorter kmers with lengths 23 to 11 (in this case)</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26"><span class="co"># maq=10 ---&gt; This will discard reads with average quality below 10</span></a>
<a class="sourceLine" id="cb6-27" data-line-number="27"><span class="co"># hdist=1 ---&gt; hamming distance of 1</span></a>
<a class="sourceLine" id="cb6-28" data-line-number="28"><span class="co"># mlf=50 ---&gt; (minlengthfraction=50) would discard reads under 50% of their original length after trimming</span></a>
<a class="sourceLine" id="cb6-29" data-line-number="29"><span class="co"># trimq=10 ---&gt; quality-trim to Q10 using the Phred algorithm, which is more accurate than naive trimming.</span></a>
<a class="sourceLine" id="cb6-30" data-line-number="30"><span class="co"># qtrim=r ---&gt; means it will quality trim the right side only</span></a>
<a class="sourceLine" id="cb6-31" data-line-number="31"><span class="co"># tpe ---&gt; which specifies to trim both reads to the same length</span></a>
<a class="sourceLine" id="cb6-32" data-line-number="32"><span class="co"># tbo ---&gt; which specifies to also trim adapters based on pair overlap detection using BBMerge (which does not require known adapter sequences)</span></a>
<a class="sourceLine" id="cb6-33" data-line-number="33"><span class="co"># mm ----&gt; Maskmiddle ignores the middle base of a kmer, can turn off with mm=f</span></a></code></pre></div>
<p>To be extra cautious and ensure that the trimming step was successful, I will run the trimmed sequences through FastQC and compare the reports. If the per base and per sequence qualities have improved and/or the adapters are absent, then I will move forward with the workflow. However, if I am still not happy with the quality of the trimmed reads, I will then run the <em>trimmed</em> reads through <code>bbduk</code> in hopes of removing persistent, unwanted sequences. I will also check the overrepresented sequences and their frequencies again, and run the most frequent overepresented sequence(s) in BLASTn.</p>
</div>
</div>
<div id="asv-assignment-with-dada2" class="section level1">
<h1><span class="header-section-number">3</span> ASV Assignment with <code>DADA2</code></h1>
<p>All of the steps in this portion of the workflow (excluding the tmux and nvim code chunks) have been adapted from Dr. Callahan’s <code>DADA2</code> <a href="https://benjjneb.github.io/dada2/tutorial.html">tutorial</a> and Dr. Lee’s amplicon <a href="https://astrobiomike.github.io/amplicon/dada2_workflow_ex">tutorial</a>.</p>
<p>To prepare for running <code>DADA2</code>, I want to separate our sequence files by locus and region. For example, you do not want to analyze your 16S and ITS2 sequences together in DADA2 – combining loci and even different regions of the same loci can interfere with the <code>DADA2</code> algorithm. For example, even if you have 16S sequences of just the V3 region, and a set of 16S sequences with the V3-V4 region, you would want to run these regions separately through the <code>DADA2</code> pipeline. The reason for this will become clearer as we get to the filtering and trimming step and the error rate prediction step.</p>
<p>To create separate directories for your sequence data, I first ensure that their file names include their amplicon that’s been sequenced for that particular sample (e.g., the 16S V4 data for Sample1 is in the file <code>Sample1_16S.V4_R1_001.fastq</code>). Then I would run the following line of code.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># make sure you are in the correct directory before doing this</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">mv</span> *_16S.V4_* 16S.V4_Seqs</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co"># format of move command: mv file_name directory_name</span></a></code></pre></div>
<p>Here I am using a <code>*</code> which is a special character that can be used to represent any character or set of characters. In this case, I am telling the <code>mv</code> command to move any files that have the <code>_16S.V4_</code> pattern anywhere in the file name to a directory called <code>16S.V4_Seqs</code>. After running this command, I make sure that my script containing the following <code>DADA2</code> R code is in the directory with the specific files you want to analyze. My <code>DADA2</code> R script is called <code>DADA2_tutorial_16S_pipeline.R</code>, which you will see me reference in a couple of code chunks.</p>
<div id="run-interactive-job-tmux-on-hpcc" class="section level2">
<h2><span class="header-section-number">3.1</span> Run Interactive Job + <code>tmux</code> on HPCC</h2>
<p>Personally, I like to run through <code>DADA2</code> via an interactive job on our HPCC. This will allow us to run scripts line by line and check the output, rather than submitting a job to run in the cluster without our supervision. Basically, this is an easy to way constantly check our progress and (ideally) catch errors as soon as they happen. Again, your HPCC must use Slurm to run an interactive job in this manner.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ex">srun</span> --partition=node_name_here --mem=400gb --cpus-per-task 4 --ntasks 1 --time 08:00:00 --pty bash -l</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co"># --cpus-per-task and --ntasks are not necessary</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co"># --cpus-per-task is needed for multithreading</span></a></code></pre></div>
<p>Once the interactive job is running, we can use <strong>tmux</strong> and <strong>nvim</strong> to start running through the <code>DADA2</code> R script.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ex">tmux</span> new -s mysession <span class="co"># start new tmux session named mysession; do this if you have not started running tmux already</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ex">nvim</span> DADA2_tutorial_16S_pipeline.R <span class="co"># load R script using nvim</span></a></code></pre></div>
<center>
<img src="amplicon_workflow/nvim_openR.png" />
</center>
<div align="center">
Figure 4a: Neovim Display of R script
</div>
<p></br></p>
Almost immediately after the R script opens in nvim, I type <code>\rf</code>. This will open another window showing your terminal. You can toggle the horizontal verses vertical alignment fo the windows by typing <code>Ctrl-w shift-H</code> for a horizontal alignment or <code>Ctrl-w shift-V</code>for a vertical alignment. Below is what the screen should look like after typing <code>\rf</code> followed by <code>Ctrl-w shift-H</code>. You can see the R script is open in the left window, and my terminal is open in the right window.
<center>
<img src="amplicon_workflow/nvim_horizontal.png" />
</center>
<div align="center">
Figure 4b: View of Neovim Display after typing <code>\rf</code>
</div>
<p></br> Now that we are in nvim, all you need to do to run a line of code is to just hit the <code>space</code> bar! You can also toggle between windows using <code>Ctrl-w w</code>, edit or type code by pressing <code>i</code> to insert code, and leaving the editing mode by pressing <code>esc</code>. To quit and save changes to your R file, just type <code>:wq</code>, or to quit without saving changes to your file, just type <code>:q!</code>. When using nvim, I keep Dr. Girke’s handy <a href="https://girke.bioinformatics.ucr.edu/GEN242/tutorials/linux/linux/#basic-usage-of-nvim-r-tmux">tmux/nvim tutorial</a> open as a reference just in case.</p>
<div id="load-the-path-fastq-files" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Load the path &amp; FASTQ files</h3>
<p>We can start by loading the libraries we need as well as the path to the sequences you want to analyze. In this example I will be analyzing 16S V3-V4 sequences, so I set the path object to be the path to those specific sequences.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">getwd</span>() <span class="co"># double check that we are in the correct directory, where are trimmed sequences are stored.</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">packageVersion</span>(<span class="st">&quot;dada2&quot;</span>) <span class="co"># Should be 1.16</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">suppressPackageStartupMessages</span>({ <span class="co"># load packages quietly</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="kw">library</span>(dada2)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="kw">library</span>(tidyr)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="kw">library</span>(ggpubr)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  <span class="kw">library</span>(decontam)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">})</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">path &lt;-<span class="st"> &quot;/path/to/fastq/files&quot;</span> <span class="co"># CHANGE ME to the directory containing the fastq files after </span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="kw">list.files</span>(path)</a>
<a class="sourceLine" id="cb10-14" data-line-number="14"></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">## Read in sample names</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">fnFs &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">list.files</span>(path, <span class="dt">pattern=</span><span class="st">&quot;_R1_clean.fastq&quot;</span>, <span class="dt">full.names =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">fnFs <span class="co"># sanity check to see what the file names are</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">fnRs &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">list.files</span>(path, <span class="dt">pattern=</span><span class="st">&quot;_R2_clean.fastq&quot;</span>, <span class="dt">full.names =</span> <span class="ot">TRUE</span>)); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>) <span class="co"># saves all objects in global env.; runs after portion of code before &quot;;&quot;</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"><span class="co"># Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">sample.names &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="kw">strsplit</span>(<span class="kw">basename</span>(fnFs), <span class="st">&quot;_R1&quot;</span>), <span class="st">`</span><span class="dt">[</span><span class="st">`</span>, <span class="dv">1</span>) <span class="co">#pattern where you want to split the name; i.e., at the _R1 level</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23"><span class="co">## want to split by R1 so that you do not get duplicate sample names for each R1/R2 paired-end sequences</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24"><span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>) <span class="co"># save global env.</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25"></a>
<a class="sourceLine" id="cb10-26" data-line-number="26">sample.names <span class="co"># sanity check</span></a></code></pre></div>
<p>If you have already started the <code>DADA2</code> workflow and want to pick up from where you left off, then you can run this next code chunk to load everything that was in your global environment and saved to an .Rdata object (I will explain this code when we save our first .Rdata file).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">## If you are picking up where you left off, load your mydada_16S.V4.Rdata file now</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">load</span>(<span class="st">&quot;/path/to/fastq/files/mydada_16S.V4.Rdata&quot;</span>)</a></code></pre></div>
</div>
</div>
<div id="check-sequence-quality" class="section level2">
<h2><span class="header-section-number">3.2</span> Check sequence quality</h2>
<p>Though we have already done this with <code>FastQC</code>, there is a step here to check the quality of our forward and reverse reads. These per base sequence quality reports do look nicer than the <code>FastQC</code> output and tell you the total number of reads in that particular sample. We use <code>ggsave()</code> from the <code>ggpubr</code> <a href="https://rpkgs.datanovia.com/ggpubr/index.html">package</a> <span class="citation">(Kassambara 2020)</span> to save these reports as high quality PDFs.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">plot1&lt;-<span class="kw">plotQualityProfile</span>(fnFs[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]) <span class="co"># check quality of Forward reads (2 samples)</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">plot2&lt;-<span class="kw">plotQualityProfile</span>(fnRs[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]) <span class="co"># check quality of Reverse reads (2 samples)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">ggsave</span>(plot1,<span class="dt">filename =</span> <span class="st">&quot;16S_pretrim_DADA2_F_quality.pdf&quot;</span>, <span class="dt">width=</span><span class="dv">15</span>, <span class="dt">height=</span><span class="dv">12</span>, <span class="dt">dpi=</span><span class="dv">600</span>) </a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">ggsave</span>(plot2,<span class="dt">filename =</span> <span class="st">&quot;16S_pretrim_DADA2_R_quality.pdf&quot;</span>, <span class="dt">width=</span><span class="dv">15</span>, <span class="dt">height=</span><span class="dv">12</span>, <span class="dt">dpi=</span><span class="dv">600</span>) </a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_pretrim_DADA2_F_quality.png" />
</center>
<div align="center">
Figure 5a: Per Base Sequence Quality Reports for 2 Samples (R1 Only)
</div>
</br>
<center>
<img src="amplicon_workflow/16S_pretrim_DADA2_R_quality.png" />
</center>
<div align="center">
Figure 5b: Per Base Sequence Quality Reports for 2 Samples (R2 Only)
</div>
<p></br></p>
</div>
<div id="filter-and-trim" class="section level2">
<h2><span class="header-section-number">3.3</span> Filter and Trim</h2>
<p>Now that we’ve set up our file paths and checked the quality of our sequences, we can set them up for the <code>DADA2</code> filter and trim step. First, we create objects that will hold the file names of filtered sequences based on the sample names we have provided. Then the <code>filterAndTrim</code> command will filter the reads based upon the following: read quality, read length, the number of Ns (i.e., unknown bases) in a read, the maximum number of expected errors after truncating the reads, and whether or not reads in your sample match the PhiX genome (i.e., a small virus genome used as a control in Illumina sequencing runs; more information <a href="https://dornsife.usc.edu/uscgenomecore/faq/">here</a>). The maximum expected errors is calculated by solving for E in the Quality Score equation (see above). We have also specified here that we would like our output FASTQ files to be compressed, and that we can multithread this filter and trimming process. Keep in mind that if you are using a <strong>Windows</strong> to run your analyses locally, then multithreading is not available for this step.</p>
<p>Soem crucial things to consider at this step are your read lengths (i.e., 2x250, 2x300), the locus and region(s) you’re sequencing, the per base quality of your sequences, the and whether you are using paired-end reads or just forward reads.</p>
<p>For the <strong>ITS1</strong> and <strong>ITS2</strong> genes, their lengths vary so wildly that truncating the sequences based on a specific length is not recommended. However, for the <strong>16S gene</strong>, its regions (i.e., V1-V9) are a bit more reliable in their average lengths. The <strong>16S V4</strong> region varies between ~250 - 283 nucleotides in length <span class="citation">(Illumina, n.d.; Vargas-Albores et al. 2017)</span>, whereas the <strong>V3</strong> region varies between ~130 to 190 nucleotides <span class="citation">(Vargas-Albores et al. 2017)</span>. The <strong>V3-V4</strong> region ranges between ~400 - 470 nucleotides in length. For more information, check out this <code>DADA2</code> GitHub <a href="https://github.com/benjjneb/dada2/issues/1033">issue</a> as well as <span class="citation">Rausch et al. (2019)</span> and <span class="citation">Bukin et al. (2019)</span>.</p>
<p>Forward and reverse reads are merged if they have at least a <em>12 base pair</em> overlap. If you are using paired-end reads, then your merged read lengths (considering the 12 nucleotide overlap) need to total up to these region lengths. For example, let’s say you’re truncating your 16S V3-V4 forward reads to 250 base pairs (bp) long and your reverse reads to 160 bp long. If your reads are merged, the total length will be 250 + (160-12) = 398 bp long. This total read length of 398 bp would be a decent minimum read length considering that the range of the 16S V3-V4 region is ~400 - 470 bp.</p>
<p>Lastly, when setting your expected errors per forward and reverse reads (<code>maxEE=c(R1,R2)</code>), it is important to consider the per base sequence quality of your reads. Because reverse reads typically have lower per base sequence quality than your forward reads, you may want to relax the expected errors for your reverse reads.</p>
<p>If few too reads are surviving this step, then consider changing your expected errors per read parameter or adjusting the <code>truncLength</code> of your reads. Referring to your FastQC and eestats2 reports may be provide even more clarity for how you want to define these paramters. For more information on the <code>filterAndTrim</code> function, please view this <a href="https://rdrr.io/github/benjjneb/dada2/man/filterAndTrim.html">documentation</a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">path <span class="co"># double check that your path is correct</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co"># Create objects that will hold filtered file names in directory called &quot;Filtered&quot;</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="co">## these files will be created in the filter + trim step w/ filterAndTrim command</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">filtFs &lt;-<span class="st"> </span><span class="kw">file.path</span>(path, <span class="st">&quot;Filtered&quot;</span>, <span class="kw">paste0</span>(sample.names, <span class="st">&quot;_F_filtered.fastq.gz&quot;</span>))</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">filtRs &lt;-<span class="st"> </span><span class="kw">file.path</span>(path, <span class="st">&quot;Filtered&quot;</span>, <span class="kw">paste0</span>(sample.names, <span class="st">&quot;_R_filtered.fastq.gz&quot;</span>))</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="co"># giving these file.name elements the sames of the samples</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="kw">names</span>(filtFs) &lt;-<span class="st"> </span>sample.names</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="kw">names</span>(filtRs) &lt;-<span class="st"> </span>sample.names; <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">filtFs <span class="co"># let&#39;s see what this object looks like</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="co"># Filter &amp; Trim! </span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">out &lt;-<span class="st"> </span><span class="kw">filterAndTrim</span>(fnFs, filtFs, fnRs, filtRs, <span class="dt">truncLen=</span><span class="kw">c</span>(<span class="dv">250</span>,<span class="dv">235</span>),</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                     <span class="dt">maxN=</span><span class="dv">0</span>, <span class="dt">maxEE=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="dt">truncQ=</span><span class="dv">2</span>, <span class="dt">rm.phix=</span><span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">                     <span class="dt">compress=</span><span class="ot">TRUE</span>, <span class="dt">multithread=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>) <span class="co"># On Windows set multithread=FALSE</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18"></a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="co"># filterAndTrim notes:</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="co">## The maxEE parameter sets the maximum number of “expected errors” allowed in a read, which is a better filter than simply averaging quality scores.</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21"><span class="co">## Standard filtering parameters: maxN=0 (DADA2 requires no Ns), truncQ=2, rm.phix=TRUE and maxEE=2.</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22"><span class="co"># truncLen=c(240,230) -- trim F reads to 240 bp, trim R reads to 230 bp</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23"><span class="co">## Notes for trunc length of 2x300 PE reads: https://github.com/benjjneb/dada2/issues/236</span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"></a>
<a class="sourceLine" id="cb13-25" data-line-number="25"><span class="kw">head</span>(out)</a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="co"># * if you are only doing F reads, remove the &quot;truncLen&quot; command - truncLen=c(240,160) [for PE reads]</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"><span class="co"># sometimes there is a trimLeft=15 argument here, but I removed this because I already trimmed my sequences with bbduk</span></a></code></pre></div>
<div id="learn-the-error-rates" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Learn the Error Rates</h3>
<p>Dr. Callahan developed an algorithm for a parametric error model that can use both inference and estimations to determine the error rates for each sample. Here is the excerpt of Dr. Callahan describing this function in his <code>DADA2</code> <a href="https://benjjneb.github.io/dada2/tutorial.html">tutorial</a>.</p>
<blockquote>
<p>The DADA2 algorithm makes use of a parametric error model (<code>err</code>) and every amplicon dataset has a different set of error rates. The learnErrors method learns this error model from the data, by alternating estimation of the error rates and inference of sample composition until they converge on a jointly consistent solution. As in many machine-learning problems, the algorithm must begin with an initial guess, for which the maximum possible error rates in this data are used (the error rates if only the most abundant sequence is correct and all the rest are errors).</p>
</blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">errF &lt;-<span class="st"> </span><span class="kw">learnErrors</span>(filtFs, <span class="dt">multithread=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">errR &lt;-<span class="st"> </span><span class="kw">learnErrors</span>(filtRs, <span class="dt">multithread=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co"># The learnErrors method learns this error model from the data by alternating estimation of the error rates and inference of sample composition until they converge on a jointly consistent solution.</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="co"># As in many machine-learning (ML) problems, the algorithm must begin with an initial guess, for which the maximum possible error rates in this data are used (the error rates if only the most abundant sequence is correct and all the rest are errors)</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">plot_error&lt;-<span class="kw">plotErrors</span>(errF, <span class="dt">nominalQ=</span><span class="ot">TRUE</span>)<span class="co">## sanity check by visualizing estimated error rates -- should see error rates drop w/ increased quality</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">ggsave</span>(plot_error,<span class="dt">filename =</span> <span class="st">&quot;16S_errormodel_DADA2.pdf&quot;</span>, <span class="dt">width=</span><span class="dv">15</span>, <span class="dt">height=</span><span class="dv">15</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_errormodel_DADA2.png" />
</center>
<div align="center">
Figure 6: Rarefaction Curve Example
</div>
<p></br></p>
<p>Once we have constructed the error model from the reads, we can plot the observed frequency of transitions from base to base (i.e., A2A indicates an A followed by an A) as a function of the consensus quality score at that position in the read. The individual points in black represent the observed error rates for each consensus quality score. The black line shows estimated error rates after convergence of the ML algorithm, and the red line shows error rates expected under the nominal definition of the Q-score. One thing we notice is that as consensus quality score increases, the error rates (black lines) decrease, which is expected.</p>
<p>If it seems like we are doing a lot of sanity checks throughout this workflow, it’s because we are! This process can take a while and require some trouble shooting, so it’s good to constantly check your work as you make your way through the workflow. Coding without sanity checks is never recommended.</p>
</div>
<div id="identify-asvs-in-reads" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Identify ASVs in Reads</h3>
<p>Before we run the Divisive Amplicon Denoising Algorithm (<code>dada()</code>), we have to remove the files from our <code>filtFs/filtRs</code> objects that were dropped in the filtering step. The algorithm will not work if we include file names of files that do not actually exist in the <strong>Filtered</strong> directory.</p>
<p>Now it’s time to use the <code>dada</code> algorithm to infer our amplicon sequence variants (ASVs) from our sequences. For more information on how the Divisive Amplicon Denoising Algorithm works, please see <span class="citation">Callahan et al. (2016)</span> and <span class="citation">Rosen et al. (2012)</span>. To increase the signal of sequence variants with very low abundance across samples, you can choose to pool (<code>pool=TRUE</code>) or pseudo-pool (<code>pool=pseudo</code>) your sample sequences together.</p>
<p>The output of the algorithm will be a <code>data-class</code> object, containing the number of ASVs inferred out of the number of total input sequences.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">filtFs &lt;-<span class="st"> </span>filtFs[<span class="kw">file.exists</span>(filtFs)] <span class="co"># removes files that were not included in output because 0 reads passed filter step</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">filtRs &lt;-<span class="st"> </span>filtRs[<span class="kw">file.exists</span>(filtRs)]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">dadaFs &lt;-<span class="st"> </span><span class="kw">dada</span>(filtFs, <span class="dt">err=</span>errF, <span class="dt">multithread=</span><span class="ot">TRUE</span>, <span class="dt">pool=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>) <span class="co"># pseudo pooling is computationally more efficient but similar in results to pooling; pool = True will pool samples together before sample inference</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">dadaRs &lt;-<span class="st"> </span><span class="kw">dada</span>(filtRs, <span class="dt">err=</span>errR, <span class="dt">multithread=</span><span class="ot">TRUE</span>, <span class="dt">pool=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">dadaFs[<span class="dv">1</span>] <span class="co"># Returns first section of dada-class object {one sample}</span></a></code></pre></div>
<p>The wonderful thing about ASVs is that because they are assigned based on 99% sequence identity, they are true representative of biological sequences and thus directly comparable across workflows <span class="citation">(Prodan et al. 2020; Callahan, McMurdie, and Holmes 2017)</span>. I highly recommend reading these papers for more information on the benefits of using ASVs/ESVs/zOTUs.</p>
</div>
</div>
<div id="merge-forward-reverse-reads" class="section level2">
<h2><span class="header-section-number">3.4</span> Merge Forward + Reverse Reads</h2>
<p>At this point in the workflow, we are now going to merge our denoised Forward and Reverse reads to get our contiguous sequences (i.e., contigs). Sequences will be merged if they share at least 12 nucleotides. These sequences must be identical to each other in these overlapping regions or else they will not be merged.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">mergers &lt;-<span class="st"> </span><span class="kw">mergePairs</span>(dadaFs, filtFs, dadaRs, filtRs, <span class="dt">verbose=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">head</span>(mergers[[<span class="dv">1</span>]])</a></code></pre></div>
<p>The <code>mergers</code> object is a <code>data.frame</code> containing the merged sequence, its abundance, and some statistics about the sequences themselves. If most of your reads do not merge, then you should revisit the filter and trimming step. It could be that you cut too much off of your sequencing reads, making it more difficult to successfully merge your reads.</p>
</div>
<div id="create-sequence-table-remove-chimeras" class="section level2">
<h2><span class="header-section-number">3.5</span> Create Sequence Table &amp; Remove Chimeras</h2>
<p>Let’s make an ASV table (similar to an OTU table but using ASVs), which will have our samples as rows and our ASVs as columns.</p>
<p>Using this table, we get a sense of how long our ASVs are and the distribution of these ASV lengths. We can also determine the percentage of reads that fall within our desired range of region lengths.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">seqtab &lt;-<span class="st"> </span><span class="kw">makeSequenceTable</span>(mergers); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="kw">dim</span>(seqtab)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">table</span>(<span class="kw">nchar</span>(<span class="kw">getSequences</span>(seqtab)))</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="co"># we can filter out ASVs that are not within our target range of lengths</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">seqtab2 &lt;-<span class="st"> </span>seqtab[,<span class="kw">nchar</span>(<span class="kw">colnames</span>(seqtab)) <span class="op">%in%</span><span class="st"> </span><span class="dv">250</span><span class="op">:</span><span class="dv">290</span>] <span class="co"># here looking at ASVs that are between 250 - 290 nucleotides long</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="kw">dim</span>(seqtab2)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="kw">table</span>(<span class="kw">nchar</span>(<span class="kw">getSequences</span>(seqtab2)))</a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="co"># how many reads fall within our desired length range</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11"><span class="kw">sum</span>(seqtab2)<span class="op">/</span><span class="kw">sum</span>(seqtab) </a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13"><span class="co"># Look at merged sequences in a plot -- see their distribution and frequency of sequences of certain length</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14"><span class="co">## x axis - total number of reads per sample; y axis - density of samples w/ specific # of total reads</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">compare_reads_plot1 =<span class="st"> </span><span class="kw">ggdensity</span>(<span class="kw">rowSums</span>(seqtab), <span class="dt">fill =</span> <span class="st">&quot;blue4&quot;</span>, <span class="dt">alpha =</span> <span class="fl">0.7</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">compare_reads_plot2 =<span class="st"> </span><span class="kw">ggdensity</span>(<span class="kw">rowSums</span>(seqtab2), <span class="dt">fill =</span> <span class="st">&quot;red4&quot;</span>, <span class="dt">alpha =</span> <span class="fl">0.7</span>)</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">comp_plots&lt;-<span class="kw">ggarrange</span>(compare_reads_plot1, compare_reads_plot2,<span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;All Reads&quot;</span>, <span class="st">&quot;Reads of Desired Length&quot;</span>),<span class="dt">ncol=</span><span class="dv">1</span>, <span class="dt">nrow=</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"><span class="kw">ggsave</span>(comp_plots,<span class="dt">filename =</span> <span class="st">&quot;16S.V4_compare_total_reads.pdf&quot;</span>, <span class="dt">width=</span><span class="dv">10</span>, <span class="dt">height=</span><span class="dv">20</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a>
<a class="sourceLine" id="cb17-19" data-line-number="19"><span class="kw">dev.off</span>()</a></code></pre></div>
</div>
<div id="remove-chimeras" class="section level2">
<h2><span class="header-section-number">3.6</span> Remove Chimeras</h2>
<p>Now we are going to remove all chimeric sequences from our data. <strong>Chimeras</strong> are the the result of two or more biological sequences incorrectly joining together. This is often a result of PCR for a number of reasons. In <code>DADA2</code> specifically, chimeras are identified if they can be reconstructed from right and left segments from two or more “parent” sequences. The object <code>seqtab.nochim</code> will be our sequence table with the chimeras removed. Most of your reads should not be removed during this step. However, according to the <code>DADA2</code> <a href="https://benjjneb.github.io/dada2/faq.html">FAQ page</a> if you have more than 25% of your reads removed, then it is likely that primers are still attached to your sequences. Be sure to remove these primers in the trimming step with either <code>bbduk</code>, <code>cutadapt</code>, or <code>trimmomatic</code> and begin the workflow again.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">seqtab.nochim &lt;-<span class="st"> </span><span class="kw">removeBimeraDenovo</span>(seqtab2, <span class="dt">method=</span><span class="st">&quot;consensus&quot;</span>, <span class="dt">multithread=</span><span class="ot">TRUE</span>, <span class="dt">verbose=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co"># Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” sequences</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">dim</span>(seqtab.nochim)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="kw">dim</span>(seqtab)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="kw">dim</span>(seqtab2)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6"></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="kw">sum</span>(seqtab.nochim)<span class="op">/</span><span class="kw">sum</span>(seqtab) <span class="co"># comparing reads after chimera removal over total reads (after filtering)</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="kw">sum</span>(seqtab.nochim)<span class="op">/</span><span class="kw">sum</span>(seqtab2) <span class="co"># comparing reads after chimera removal over reads that are our desired length</span></a></code></pre></div>
</div>
<div id="track-the-reads---sanity-check" class="section level2">
<h2><span class="header-section-number">3.7</span> Track the Reads - Sanity Check</h2>
<p>Time for a sanity check and see how many reads we have at this point in our workflow. This is a great place to see if we have lost any reads, and at which steps they were lost - which can really help us determine if we trimmed our reads to the appropriate length. If a lot of reads are lost, it is recommended to check if primers and adapters are still attached to your sequences, and the truncation length of your sequences for the filter and trimming step.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">getN &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">sum</span>(<span class="kw">getUniques</span>(x)) <span class="co"># function get number of unique sequences per object</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">track &lt;-<span class="st"> </span><span class="kw">cbind</span>(out, <span class="kw">sapply</span>(dadaFs, getN), <span class="kw">sapply</span>(dadaRs, getN), <span class="kw">sapply</span>(mergers, getN), <span class="kw">rowSums</span>(seqtab.nochim)); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="co"># If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs) ;  sapply(dadaRs, getN), sapply(mergers, getN),</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="kw">head</span>(track)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="kw">colnames</span>(track) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;input&quot;</span>, <span class="st">&quot;filtered&quot;</span>, <span class="st">&quot;denoisedF&quot;</span>, <span class="st">&quot;denoisedR&quot;</span>, <span class="st">&quot;merged&quot;</span>, <span class="st">&quot;nonchim&quot;</span>) <span class="co"># remove whichever labels you didn&#39;t include</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="kw">rownames</span>(track) &lt;-<span class="st"> </span>sample.names</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"><span class="kw">head</span>(track)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9"></a>
<a class="sourceLine" id="cb19-10" data-line-number="10"><span class="kw">write.table</span>(track,<span class="st">&quot;16S_tracking_reads_dada2.txt&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>,<span class="dt">col.names=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a></code></pre></div>
</div>
<div id="assign-taxonomy-to-asvs" class="section level2">
<h2><span class="header-section-number">3.8</span> Assign Taxonomy to ASVs</h2>
<p>Now it’s time to assign taxonomic identities to our ASVs. Dr. Callahan utilizes the <a href="https://pubmed.ncbi.nlm.nih.gov/17586664/">naive Bayesian classifier</a> his <code>assignTaxonomy</code> function, which is the same classifier used by the <a href="https://rdp.cme.msu.edu/">Ribosomal Database Project</a> (RDP) for taxonomic assignment. For more information on how this classifier works, please read <span class="citation">Wang et al. (2007)</span>.</p>
<p>In order to assign the taxonomic IDs to our ASVs, we need to have a reference database FASTA file to use as our known training data. These training data with known references will help the classifier determine which taxa our ASVs belong to. Currently the options for reference databases include the latest versions of the <strong>Silva</strong> database (for 16S), the <strong>Ribosomal Database Project</strong> database (for 16S), and the <strong>UNITE</strong> database (which should be used specifically for ITS sequences). A <strong>Green Genes</strong> database file is also included (for 16S analyses), but Green Genes has not been updated in a long time and thus is not the best choice for our reference training dataset. Dr. Callahan has included these reference database files <a href="https://benjjneb.github.io/dada2/training.html">here</a>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">taxa &lt;-<span class="st"> </span><span class="kw">assignTaxonomy</span>(seqtab.nochim, <span class="st">&quot;/bigdata/aronsonlab/shared/DADA2_Silva_Files/silva_nr99_v138.1_wSpecies_train_set.fa.gz&quot;</span>, <span class="dt">multithread=</span><span class="ot">TRUE</span>); <span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">taxa.print &lt;-<span class="st"> </span>taxa <span class="co"># Removing sequence rownames for display only</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="kw">rownames</span>(taxa.print) &lt;-<span class="st"> </span><span class="ot">NULL</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="kw">head</span>(taxa.print) <span class="co"># view taxonomic assignments</span></a></code></pre></div>
<p>If you are only seeing taxonomic identification at the Phyla level (i.e., the rest of the columns are filled with <code>NAs</code>), then this could indicate that we have not trimmed our sequences correctly. For example, let’s say we have reads that are 300bp long (from 2x300 PE sequencing), but we are interested in the 16S V3 region which ranges from ~ 130-190 nucleotides in length. If we have not trimmed our sequences down to our desired region length (here 130-190 nucleotides), then our merged reads are no longer reliable, and the classifier will incorrectly identify our ASVs. Remember, the reads need to have at least a 12 nucleotide overlap to merge - so if we are not trimming our reads correctly, we could create merged sequences that are not accurate representations of the regions we are trying to identify, which will hurt us in the taxonomic assignment step.</p>
</div>
<div id="save-dada2-output-for-future-analysis" class="section level2">
<h2><span class="header-section-number">3.9</span> Save DADA2 Output for future analysis</h2>
<p>We have finished the <code>DADA2</code> portion of the workflow! We can save the output from <code>DADA2</code> as R objects, text files, and tsv files for future import into R.</p>
<p>First we create a vector of the ASV labels called <code>asv_headers</code> that we will use to make the ASV IDs easier to read. We then use a for loop to add an “ASV” prefix to our <code>asv_headers</code> so that they are easily identifiable by an ASV number instead of just a number to represent each ASV. We then combine <code>asv_headers</code> with the sequences themselves to make an object called <code>asv_fasta</code>, which now holds our ASV sequences and their respective IDs.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co"># giving our seq headers more manageable names (ASV_1, ASV_2...)</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">asv_seqs &lt;-<span class="st"> </span><span class="kw">colnames</span>(seqtab.nochim)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">asv_headers &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="kw">dim</span>(seqtab.nochim)[<span class="dv">2</span>], <span class="dt">mode=</span><span class="st">&quot;character&quot;</span>)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">head</span>(seqtab.nochim)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">head</span>(asv_headers)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">dim</span>(seqtab.nochim)[<span class="dv">2</span>]) {</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  asv_headers[i] &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;&gt;ASV&quot;</span>, i, <span class="dt">sep=</span><span class="st">&quot;_&quot;</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">asv_fasta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rbind</span>(asv_headers, asv_seqs))</a></code></pre></div>
<p>Now we can save our ASV count table, our ASV taxonomy table, and the ASV sequences themselves as separate files and R objects. I wanted to provide several file options because some people have a preference as to how they import data into R.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co"># making and writing out a fasta file of our final ASV seqs w/ ASV IDs:</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">write</span>(asv_fasta, <span class="st">&quot;16S_ASVs_dada2.fa&quot;</span>) <span class="co"># write fasta file</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="kw">write.table</span>(asv_fasta,<span class="st">&quot;16S_ASVs_dada2.txt&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>,<span class="dt">col.names=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="co"># ASV count table:</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">asv_counts &lt;-<span class="st"> </span><span class="kw">t</span>(seqtab.nochim)</a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="kw">row.names</span>(asv_counts) &lt;-<span class="st"> </span><span class="kw">sub</span>(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;&quot;</span>, asv_headers)</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="co"># For Vegan format: sample IDs as rows, ASVs as columns</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">asv_tab&lt;-<span class="kw">t</span>(asv_counts)</a>
<a class="sourceLine" id="cb22-11" data-line-number="11"><span class="kw">write.table</span>(asv_tab, <span class="st">&quot;16S.V4_ASVs_Table_dada2.tsv&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">quote=</span>F, <span class="dt">col.names=</span><span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"><span class="kw">write.table</span>(asv_tab,<span class="st">&quot;16S.V4_ASVs_Table_dada2.txt&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>,<span class="dt">col.names=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="co"># For Phyloseq format: ASVs as row IDs, sample IDs as columns</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14"><span class="kw">write.table</span>(asv_counts, <span class="st">&quot;16S.V4_ASVs_Counts_dada2.tsv&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">quote=</span>F, <span class="dt">col.names=</span><span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb22-15" data-line-number="15"><span class="kw">write.table</span>(asv_counts,<span class="st">&quot;16S.V4_ASVs_Counts_dada2.txt&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>,<span class="dt">col.names=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb22-16" data-line-number="16"></a>
<a class="sourceLine" id="cb22-17" data-line-number="17"><span class="co"># taxa ID table:</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">asv_tax &lt;-<span class="st"> </span>taxa</a>
<a class="sourceLine" id="cb22-19" data-line-number="19"><span class="kw">row.names</span>(asv_tax) &lt;-<span class="st"> </span><span class="kw">sub</span>(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;&quot;</span>, asv_headers)</a>
<a class="sourceLine" id="cb22-20" data-line-number="20"><span class="kw">write.table</span>(asv_tax, <span class="st">&quot;16S.V4_ASVs_Taxonomy_dada2.tsv&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">quote=</span>F, <span class="dt">col.names=</span><span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb22-21" data-line-number="21"><span class="kw">write.table</span>(asv_tax,<span class="st">&quot;16S.V4_ASVs_Taxonomy_dada2.txt&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>,<span class="dt">col.names=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb22-22" data-line-number="22"></a>
<a class="sourceLine" id="cb22-23" data-line-number="23"><span class="co">#### Save all ASV objects as R objects ####</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24"><span class="kw">saveRDS</span>(asv_tax, <span class="dt">file =</span> <span class="st">&quot;16S.V4_ASVs_Taxonomy_dada2_Robject.rds&quot;</span>, <span class="dt">ascii =</span> <span class="ot">FALSE</span>, <span class="dt">version =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb22-25" data-line-number="25">        <span class="dt">compress =</span> <span class="ot">TRUE</span>, <span class="dt">refhook =</span> <span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb22-26" data-line-number="26"><span class="kw">saveRDS</span>(asv_tab, <span class="dt">file =</span> <span class="st">&quot;16S.V4_ASVs_Counts_dada2_Robject.rds&quot;</span>, <span class="dt">ascii =</span> <span class="ot">FALSE</span>, <span class="dt">version =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb22-27" data-line-number="27">        <span class="dt">compress =</span> <span class="ot">TRUE</span>, <span class="dt">refhook =</span> <span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb22-28" data-line-number="28"><span class="kw">saveRDS</span>(asv_fasta, <span class="dt">file =</span> <span class="st">&quot;16S.V4_ASV_Sequences_dada2_Robject.rds&quot;</span>, <span class="dt">ascii =</span> <span class="ot">FALSE</span>, <span class="dt">version =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb22-29" data-line-number="29">        <span class="dt">compress =</span> <span class="ot">TRUE</span>, <span class="dt">refhook =</span> <span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb22-30" data-line-number="30"></a>
<a class="sourceLine" id="cb22-31" data-line-number="31"><span class="co">#### Save everything from global environment into .Rdata file</span></a>
<a class="sourceLine" id="cb22-32" data-line-number="32"><span class="kw">save.image</span>(<span class="dt">file =</span> <span class="st">&quot;mydada_16S.V4.Rdata&quot;</span>)</a></code></pre></div>
<p>Personally, I like using R objects (file extension .rds) in my analyses. In order to import R objects into R, you can run <code>data.frame(readRDS(&quot;path/to/Robject.rds&quot;, refhook = NULL))</code> to create a data frame holding the contents of your R object file.</p>
</div>
</div>
<div id="statistical-analysis" class="section level1">
<h1><span class="header-section-number">4</span> Statistical Analysis</h1>
<p>At this point you should have either/or R objects, text files, and tsv files containing the following: 1. your ASV sequences in FASTA format, 2. your ASV count table, and 3. your ASV taxonomy table. You should also have some metadata for your samples that will allow for deeper investigation into your microbial data.</p>
<div id="import-and-prepare-data-for-analyses" class="section level2">
<h2><span class="header-section-number">4.1</span> Import and Prepare Data for Analyses</h2>
<p>First before we import any data, let’s make sure that we are in the right directory (where our <code>DADA2</code> files are stored) and that have all of the necessary R libraries loaded.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">getwd</span>() <span class="co"># use setwd(&quot;path/to/files&quot;) if you are not in the right directory</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="kw">setwd</span>(<span class="st">&quot;/Volumes/HLF_SSD/Sequence_Analyses_scripts/Amplicon_WF_Rmarkdown/Amplicon_WF_SampleData&quot;</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="kw">suppressPackageStartupMessages</span>({ <span class="co"># load packages quietly</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">library</span>(phyloseq)</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">library</span>(ggplot2)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">library</span>(vegan)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  <span class="kw">library</span>(ggpubr)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  <span class="kw">library</span>(scales)</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  <span class="kw">library</span>(grid)</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  <span class="kw">library</span>(ape)</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">  <span class="kw">library</span>(plyr)</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  <span class="kw">library</span>(dplyr)</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  <span class="kw">library</span>(readxl)</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">  <span class="kw">library</span>(dplyr)</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">  <span class="kw">library</span>(tidyr)</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">  <span class="kw">library</span>(reshape)</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">  <span class="kw">library</span>(reshape2)</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">  <span class="kw">library</span>(wesanderson)</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">  <span class="kw">library</span>(nationalparkcolors)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">  <span class="kw">library</span>(shades)</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">  <span class="kw">library</span>(microbiome)</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">  <span class="kw">library</span>(devtools)</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">})</a></code></pre></div>
<p>Now let’s import the <code>DADA2</code> output into R for some statistical analyses. We will import our ASV count table, our ASV taxonomic table, and our metadata for this dataset. We are also going to create an object called <code>colorset1</code> to contain the color labels for each of our categories. This will help us keep the colors consistent for each category in all of our figures.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co">## Import bacterial ASV count data</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">bac.ASV_counts&lt;-<span class="kw">data.frame</span>(<span class="kw">readRDS</span>(<span class="st">&quot;16S.V4_MSH_ASVs_Counts_dada2_9.20.2021_Robject.rds&quot;</span>, <span class="dt">refhook =</span> <span class="ot">NULL</span>))</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">dim</span>(bac.ASV_counts)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4"><span class="kw">head</span>(bac.ASV_counts)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">colnames</span>(bac.ASV_counts)&lt;-<span class="kw">gsub</span>(<span class="st">&quot;X1&quot;</span>, <span class="st">&quot;1&quot;</span>, <span class="kw">colnames</span>(bac.ASV_counts)) <span class="co"># shorten sample names to match sample names in metadata file</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">bac.ASV_counts<span class="op">$</span>ASV_ID&lt;-<span class="kw">rownames</span>(bac.ASV_counts)</a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">head</span>(bac.ASV_counts)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="co">## Import metadata</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">metadata&lt;-<span class="kw">as.data.frame</span>(<span class="kw">read_excel</span>(<span class="st">&quot;MSH_MappingFile_for_Workflow.xlsx&quot;</span>), <span class="dt">header=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">head</span>(metadata)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">metadata&lt;-<span class="kw">na.omit</span>(metadata) <span class="co"># drop NAs from metadata</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="kw">head</span>(metadata)</a>
<a class="sourceLine" id="cb24-14" data-line-number="14">metadata<span class="op">$</span>SampleID&lt;-<span class="kw">gsub</span>(<span class="st">&quot;(</span><span class="ch">\\</span><span class="st">_.*?)</span><span class="ch">\\</span><span class="st">_([0-9])&quot;</span>,<span class="st">&quot;</span><span class="ch">\\</span><span class="st">1.</span><span class="ch">\\</span><span class="st">2&quot;</span>, metadata<span class="op">$</span>SampleID) <span class="co"># replace second _ with .</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15"><span class="kw">rownames</span>(metadata)&lt;-metadata<span class="op">$</span>SampleID</a>
<a class="sourceLine" id="cb24-16" data-line-number="16"></a>
<a class="sourceLine" id="cb24-17" data-line-number="17"><span class="co"># create color variable(s) to identify variables by colors</span></a>
<a class="sourceLine" id="cb24-18" data-line-number="18"><span class="co">## color for Category</span></a>
<a class="sourceLine" id="cb24-19" data-line-number="19">colorset1 =<span class="st"> </span><span class="kw">melt</span>(<span class="kw">c</span>(<span class="dt">ClearCutSoil=</span><span class="st">&quot;#D00000&quot;</span>,<span class="dt">Gopher=</span><span class="st">&quot;#f8961e&quot;</span>,<span class="dt">NoGopher=</span><span class="st">&quot;#4ea8de&quot;</span>,<span class="dt">OldGrowth=</span><span class="st">&quot;#283618&quot;</span>))</a>
<a class="sourceLine" id="cb24-20" data-line-number="20"></a>
<a class="sourceLine" id="cb24-21" data-line-number="21">colorset1<span class="op">$</span>Category&lt;-<span class="kw">rownames</span>(colorset1)</a>
<a class="sourceLine" id="cb24-22" data-line-number="22"><span class="kw">colnames</span>(colorset1)[<span class="kw">which</span>(<span class="kw">names</span>(colorset1) <span class="op">==</span><span class="st"> &quot;value&quot;</span>)] &lt;-<span class="st"> &quot;Category_col&quot;</span></a>
<a class="sourceLine" id="cb24-23" data-line-number="23">colorset1</a>
<a class="sourceLine" id="cb24-24" data-line-number="24"></a>
<a class="sourceLine" id="cb24-25" data-line-number="25">metadata&lt;-<span class="kw">merge</span>(metadata, colorset1, <span class="dt">by=</span><span class="st">&quot;Category&quot;</span>)</a>
<a class="sourceLine" id="cb24-26" data-line-number="26"><span class="kw">head</span>(metadata)</a>
<a class="sourceLine" id="cb24-27" data-line-number="27">metadata<span class="op">$</span>Category_col &lt;-<span class="st"> </span><span class="kw">as.character</span>(metadata<span class="op">$</span>Category_col)</a>
<a class="sourceLine" id="cb24-28" data-line-number="28"><span class="kw">rownames</span>(metadata)&lt;-metadata<span class="op">$</span>SampleID</a>
<a class="sourceLine" id="cb24-29" data-line-number="29"></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"><span class="co">## Import ASV taxonomic data</span></a>
<a class="sourceLine" id="cb24-31" data-line-number="31">bac.ASV_tax&lt;-<span class="kw">data.frame</span>(<span class="kw">readRDS</span>(<span class="st">&quot;16S.V4_MSH_ASVs_Taxonomy_dada2_9.20.2021_Robject.rds&quot;</span>, <span class="dt">refhook =</span> <span class="ot">NULL</span>))</a>
<a class="sourceLine" id="cb24-32" data-line-number="32"><span class="kw">head</span>(bac.ASV_tax)</a>
<a class="sourceLine" id="cb24-33" data-line-number="33"></a>
<a class="sourceLine" id="cb24-34" data-line-number="34">bac.ASV_tax[<span class="kw">is.na</span>(bac.ASV_tax)]&lt;-<span class="st"> &quot;Unknown&quot;</span> <span class="co"># turn all NAs into &quot;Unkowns&quot;</span></a>
<a class="sourceLine" id="cb24-35" data-line-number="35">bac.ASV_tax<span class="op">$</span>Species&lt;-<span class="kw">gsub</span>(<span class="st">&quot;Unknown&quot;</span>, <span class="st">&quot;unknown&quot;</span>, bac.ASV_tax<span class="op">$</span>Species) <span class="co"># change uppercase Unkonwn to lowercase unknown for unknown species classification</span></a>
<a class="sourceLine" id="cb24-36" data-line-number="36"><span class="kw">head</span>(bac.ASV_tax)</a>
<a class="sourceLine" id="cb24-37" data-line-number="37">bac.ASV_tax<span class="op">$</span>ASV_ID&lt;-<span class="kw">rownames</span>(bac.ASV_tax) <span class="co"># create ASV ID column to use for merging data frames</span></a>
<a class="sourceLine" id="cb24-38" data-line-number="38"><span class="kw">head</span>(bac.ASV_tax)</a></code></pre></div>
<div id="data-formatting-filtering-and-transformation" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Data Formatting, Filtering, and Transformation</h3>
<p>Now that we have imported our ASV count table, our ASV taxonomy table, and our metadata, we can start to reformat the actual data objects in R to get them ready for running through the <code>vegan</code> suite of tools. First we are going to merge our ASV count table and our ASV taxonomy tables together and filter out some unwanted taxa.</p>
<p>Even though we are analyzing bacterial data, sometimes chloroplast and mitochondrial sequences are attributed to 16S genes. For example, in the Silva database, Chloroplast sequences attributed to Eukaryotes are found within the databases’ set of Cyanobacteria sequences. Some sequences within this Chloroplast distinction are actually labeled as bacteria, but they have not been phylogenetically connected to a reference genome. It’s important to filter our these eukaryotic sequences before we start playing with statistical analyses.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="co"># first we merge the ASV count object and the ASV taxonomy object together by column called &quot;ASV_ID&quot;</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">bac.ASV_dat&lt;-<span class="kw">merge</span>(bac.ASV_counts,bac.ASV_tax, <span class="dt">by=</span><span class="st">&quot;ASV_ID&quot;</span>)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="kw">head</span>(bac.ASV_dat)</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">bac.ASV_dat&lt;-<span class="kw">subset</span>(bac.ASV_dat, Kingdom<span class="op">!=</span><span class="st">&quot;Unknown&quot;</span>) <span class="co">## drop Unknowns from Kingdom</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">bac.ASV_dat&lt;-<span class="kw">subset</span>(bac.ASV_dat, Phylum<span class="op">!=</span><span class="st">&quot;Unknown&quot;</span>) <span class="co">## drop Unknowns from Phylum</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="kw">head</span>(bac.ASV_dat)</a>
<a class="sourceLine" id="cb25-8" data-line-number="8"></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">bac.ASV_dat&lt;-<span class="kw">subset</span>(bac.ASV_dat, Class<span class="op">!=</span><span class="st">&quot;Chloroplast&quot;</span>) <span class="co">## exclude Chloroplast sequences</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10">bac.ASV_dat&lt;-<span class="kw">subset</span>(bac.ASV_dat, Order<span class="op">!=</span><span class="st">&quot;Chloroplast&quot;</span>) <span class="co">## exclude Chloroplast sequences</span></a>
<a class="sourceLine" id="cb25-11" data-line-number="11">bac.ASV_dat&lt;-<span class="kw">subset</span>(bac.ASV_dat, Family<span class="op">!=</span><span class="st">&quot;Mitochondria&quot;</span>) <span class="co">## exclude Mitochondrial sequences just in case</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12"></a>
<a class="sourceLine" id="cb25-13" data-line-number="13"><span class="st">&#39;Chloroplast&#39;</span> <span class="op">%in%</span><span class="st"> </span>bac.ASV_dat <span class="co"># check if Chloroplast counts are still in df, should be false because they&#39;ve been removed</span></a>
<a class="sourceLine" id="cb25-14" data-line-number="14"><span class="st">&#39;Mitochondria&#39;</span> <span class="op">%in%</span><span class="st"> </span>bac.ASV_dat <span class="co"># check if Mitochondria counts are still in df, should be false because they&#39;ve been removed</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15"><span class="st">&#39;Undetermined&#39;</span> <span class="op">%in%</span><span class="st"> </span>bac.ASV_dat <span class="co"># check if undetermined taxa in data frame</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16"></a>
<a class="sourceLine" id="cb25-17" data-line-number="17"><span class="kw">head</span>(bac.ASV_dat)</a>
<a class="sourceLine" id="cb25-18" data-line-number="18"><span class="kw">rownames</span>(bac.ASV_dat)&lt;-bac.ASV_dat<span class="op">$</span>ASV_ID</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"><span class="kw">head</span>(bac.ASV_dat)</a></code></pre></div>
<p>After dropping unknown or undesired sequences from our combined ASV data frame, it’s time to create an ASV table that is properly formatted for the <code>vegan</code> package. This ASV table must be a <strong>Samples x Species</strong> matrix, in which our Sample IDs as our row names and our ASV IDs as our column names.</p>
<p><strong>NOTE</strong>: We could have made this ASV table earlier immediately after importing the ASV count data by transposing the table with the <code>t()</code> function. However, I want to have an ASV table that excludes taxa I do not want in my data set, like ASVs attributed to Chloroplast sequences or ASVs attributed to unknown Phyla.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">b.dat.m&lt;-<span class="kw">melt</span>(bac.ASV_dat)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="kw">head</span>(b.dat.m)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="kw">colnames</span>(b.dat.m)[<span class="kw">which</span>(<span class="kw">names</span>(b.dat.m) <span class="op">==</span><span class="st"> &quot;variable&quot;</span>)] &lt;-<span class="st"> &quot;SampleID&quot;</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="kw">colnames</span>(b.dat.m)[<span class="kw">which</span>(<span class="kw">names</span>(b.dat.m) <span class="op">==</span><span class="st"> &quot;value&quot;</span>)] &lt;-<span class="st"> &quot;Count&quot;</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">bac.ASV_table&lt;-<span class="kw">as.data.frame</span>(<span class="kw">dcast</span>(b.dat.m, SampleID<span class="op">~</span>ASV_ID, <span class="dt">value.var=</span><span class="st">&quot;Count&quot;</span>, <span class="dt">fun.aggregate=</span>sum)) <span class="co">###</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="kw">head</span>(bac.ASV_table)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8"><span class="kw">rownames</span>(bac.ASV_table)&lt;-bac.ASV_table<span class="op">$</span>SampleID</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">bac.ASV_table&lt;-<span class="kw">subset</span>(bac.ASV_table, <span class="dt">select=</span><span class="op">-</span><span class="kw">c</span>(SampleID))</a>
<a class="sourceLine" id="cb26-10" data-line-number="10"><span class="kw">head</span>(bac.ASV_table)</a></code></pre></div>
<p>The last thing we need to do before we jump into statistical analyses is reformat the metadata to be in the same order (by rows) as our ASV table. <strong>This is a crucial step!</strong> Though it may appear minor, certain functions will not correctly analyze your data if your metadata and your ASV table are not arranged in the same order. This next step will only work if the two data frames we are reordering have the same number of rows AND the same row names.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co"># double check dimensions of metadata and ASV table</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">dim</span>(metadata)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="kw">dim</span>(bac.ASV_table)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="co"># double check that the rownames exist + match</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="kw">rownames</span>(metadata)</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="kw">rownames</span>(bac.ASV_table)</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"></a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="co"># reorder metadata based off of ASV table</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">metadata=metadata[<span class="kw">rownames</span>(bac.ASV_table),]</a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="co"># here we are reordering our metadata by rows, using the rownames from our ASV table as a guide</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11"><span class="co"># this indexing method will only work if the two dfs have the same # of rows AND the same row names!</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="co"># sanity check to see if this indexing step worked</span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14"><span class="kw">head</span>(metadata)</a>
<a class="sourceLine" id="cb27-15" data-line-number="15"><span class="kw">head</span>(bac.ASV_table)</a></code></pre></div>
<p>Now that all of our files are in R and correctly formatted, we can start some statistical analyses!</p>
</div>
</div>
<div id="alpha-diversity-species-richness" class="section level2">
<h2><span class="header-section-number">4.2</span> Alpha Diversity &amp; Species Richness</h2>
<div id="rarefaction-curves" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Rarefaction Curves</h3>
<p>To calculate species richness and alpha diversity (using the Shannon-Wiener index), we will use functions from the <code>vegan</code> <a href="https://cran.r-project.org/web/packages/vegan/vegan.pdf">package</a> <span class="citation">(Oksanen et al. 2020)</span>. Before I get to the alpha diversity and species richness, I will calculate a rarefaction curve for my ASV table. The rarefaction curve tells us that after resampling a pool of N individuals per sample (x-axis), we will identify a certain number of species in said sample (y-axis). This can give us an idea if any sample is more/less species rich than other samples, which can be useful to identify outliars.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">sort</span>(<span class="kw">colSums</span>(bac.ASV_table))</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">png</span>(<span class="st">&#39;rarecurve_example.png&#39;</span>,,<span class="dt">width =</span> <span class="dv">1000</span>, <span class="dt">height =</span> <span class="dv">900</span>, <span class="dt">res=</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">rarecurve</span>(<span class="kw">as.matrix</span>(bac.ASV_table), <span class="dt">col=</span>metadata<span class="op">$</span>Category_col, <span class="dt">step=</span><span class="dv">1000</span>, <span class="dt">label=</span>F,<span class="dt">ylab=</span><span class="st">&quot;ASVs&quot;</span>)</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="co"># to show sampel labels per curve, change label=T</span></a>
<a class="sourceLine" id="cb28-5" data-line-number="5"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/rarecurve_example.png" />
</center>
<div align="center">
Figure 7: Rarefaction Curve Example, Colored by Sample Category
</div>
<p></br></p>
<p>In this rarefaction curve, each curve is colored based on its sample category: red represents “Clear Cut Soil”, yellow represents the “Gopher” category , light blue represents the “No Gopher” category, and dark green represents “Old Growth” soil. Based on this rarefaction curve, it appears that samples within the Old Growth category have a smaller, average sample size compared to the other sample categories.</p>
</div>
<div id="shannon-diversity-species-richness" class="section level3">
<h3><span class="header-section-number">4.2.2</span> Shannon Diversity &amp; Species Richness</h3>
<p>Now that I’ve viewed the rarefaction curve and looked for outliers, we can move onto the alpha diversity and species richness steps.</p>
<p>For alpha diversity and species richness measurements, we are going to use raw data. The use of raw data for any kind of analysis is quite controversial because not all of the samples have the same number of observations: for example, one of our samples may have thousands of ASV counts, whereas other samples can be much smaller or larger than that. Transforming our data can allow us to view the actual distribution of our data, revealing patterns that may have been difficult to observe in the raw data. You can find a helpful example of data transformations and the benefits via its respective Wikipedia <a href="https://en.wikipedia.org/wiki/Data_transformation_(statistics)">page</a>.</p>
<p>Some microbiologists would tell you that we should rarefy our data before moving onto any diversity assessments or downstream analyses. <em>Rarefying</em> is a type of data transformation that involves finding the sample with the minimum number of counts in all of your samples, then scaling all of your sample counts down to this size. As described with the rarefaction curve, rarefying allows you to see 1. the number of species across samples and 2. the abundance of said species across samples when sampling based on a given minimum. Historically, rarefaction was the strategy used to transform microbial data. However, more recently many statisticians have advised against rarefaction as we tend to lose a lot of information regarding low abundance OTUs/ASVs. For more information on why rarefaction is not a useful transformation method, please read “Waste Not, Want Not: Why Rarefying Microbiome Data is Inadmissable” by <span class="citation">McMurdie and Holmes (2014)</span>.</p>
<p>When we get to the section on calculating <a href="#beta-div-section">beta diversity</a>, I will provide more insight into which transformation method(s) I use and why.</p>
<p>Alpha diversity is a way to measure within-sample diversity, using an equation that considers the richness of certain species as well as the evenness of those species. The <code>vegan</code> package has a <code>diversity()</code> function that allows one to specify which diversity index the user would like to use for calculating alpha diversity. Here I use the Shannon-Wiener index for calculating alpha diversity. In order to calculate Shannon Diversity, we have to calculate Shannon Entropy, then take calculate the exponential value of the Shannon Entropy (<em>e</em> to the power of Shannon Entropy). We can also calculate species richness (i.e., how many species are present in each sample) using the <code>specnumber()</code> function from the vegan package. Once we’ve found species richness and Shannon diversity, we can combine these values into one data frame, then merge this data frame with our metadata to create one dataframe containing: Shannon entropy, Shannon diversity, species richness, and your sample metadata.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co"># if you have another package loaded that has a diversity function, you can specify that you want to use vegan&#39;s diversity function as shown below</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">Shan_ent<span class="fl">.16</span>s&lt;-vegan<span class="op">::</span><span class="kw">diversity</span>(bac.ASV_table, <span class="dt">index=</span><span class="st">&quot;shannon&quot;</span>) <span class="co"># Shannon entropy</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">Shan_div<span class="fl">.16</span>s&lt;-<span class="st"> </span><span class="kw">exp</span>(Shan_ent<span class="fl">.16</span>s) <span class="co"># Shannon Diversity aka Hill number 1</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"></a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="co"># create data frame with Shannon entropy and Shannon diversity values</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">div_16s&lt;-<span class="kw">data.frame</span>(<span class="dt">Bac_Shannon_Entropy=</span>Shan_ent<span class="fl">.16</span>s,<span class="dt">Bac_Shannon_Diversity=</span>Shan_div<span class="fl">.16</span>s)</a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="kw">class</span>(div_16s)</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">div_16s<span class="op">$</span>SampleID&lt;-<span class="kw">rownames</span>(div_16s)</a>
<a class="sourceLine" id="cb29-9" data-line-number="9"><span class="kw">head</span>(div_16s)</a>
<a class="sourceLine" id="cb29-10" data-line-number="10"></a>
<a class="sourceLine" id="cb29-11" data-line-number="11"><span class="co"># create a data frame with species richness</span></a>
<a class="sourceLine" id="cb29-12" data-line-number="12">S_16s&lt;-<span class="kw">data.frame</span>(<span class="dt">Bac_Species_Richness=</span><span class="kw">specnumber</span>(bac.ASV_table), <span class="dt">SampleID=</span><span class="kw">rownames</span>(bac.ASV_table)) <span class="co"># finds # of species per sample using RAW count data; if MARGIN = 2 it finds frequencies of species</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13"></a>
<a class="sourceLine" id="cb29-14" data-line-number="14"><span class="co"># merge richness and diversity dataframes together</span></a>
<a class="sourceLine" id="cb29-15" data-line-number="15">d.r_16s&lt;-<span class="kw">merge</span>(div_16s, S_16s, <span class="dt">by.x=</span><span class="st">&quot;SampleID&quot;</span>, <span class="dt">by.y=</span><span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb29-16" data-line-number="16"></a>
<a class="sourceLine" id="cb29-17" data-line-number="17"><span class="co"># merge w/ metadata</span></a>
<a class="sourceLine" id="cb29-18" data-line-number="18">bac.div.metadat &lt;-<span class="st"> </span><span class="kw">merge</span>(d.r_16s,metadata, <span class="dt">by.x=</span><span class="st">&quot;SampleID&quot;</span>, <span class="dt">by.y=</span><span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb29-19" data-line-number="19"><span class="kw">head</span>(bac.div.metadat)</a>
<a class="sourceLine" id="cb29-20" data-line-number="20"><span class="kw">class</span>(bac.div.metadat) <span class="co"># want data frame</span></a></code></pre></div>
<p>We can now use the data frame we made with our alpha diversity, species richness, and our metadata to create some nice figures. First want to ensure that the category of interest (i.e., in this example that will be “Category”) is the right <code>class</code> of variable for generating this figure. Because we are using a categorical identifier, it is wise for us to make sure that our <code>Category</code> variable is in the <code>factor</code> format.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">unique</span>(bac.div.metadat<span class="op">$</span>Category) <span class="co"># see how many elements there are in the Category variable</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">bac.div.metadat<span class="op">$</span>Category &lt;-<span class="st"> </span><span class="kw">factor</span>(bac.div.metadat<span class="op">$</span>Category, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>,<span class="st">&quot;Gopher&quot;</span>,<span class="st">&quot;NoGopher&quot;</span>,<span class="st">&quot;OldGrowth&quot;</span>))</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="kw">class</span>(bac.div.metadat<span class="op">$</span>Category)</a></code></pre></div>
<p>Now let’s make some pretty figures with <code>ggplot2</code> <span class="citation">(Wickham 2016)</span>! Using <code>ggplot2</code>, we can specify what type of plot to make, the color palette you’ll use, the size(s) of your font, etc. If you’re interested in everything that <code>ggplot2</code> can do, please check out this amazing <code>ggplot2</code> <a href="https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf">Cheat Sheet</a>. We are also using <code>ggpubr</code>, a wrapper for <code>ggplot2</code> that allows for easy manipulation and export of <code>ggplot</code> figures. For more information on <code>ggpubr</code>, please check out the package <a href="https://rpkgs.datanovia.com/ggpubr/#:~:text=ggplot2%2C%20by%20Hadley%20Wickham%2C%20is,elegant%20data%20visualization%20in%20R.&amp;text=The%20&#39;ggpubr&#39;%20package%20provides%20some,&#39;%2D%20based%20publication%20ready%20plots">website</a>.</p>
<p>Here we are going to create box-and-whisker plots of our alpha diversity and species richness data. The first plot will display the alpha diversity across of our groups, and the second plot will display the species richness of these groups. The <code>y-axis</code> will show the Shannon diversity in the first plot, and the species richness in the second plot. For both plots, the <code>x-axis</code> will display the Category labels.</p>
<p>Each of the individual box-and-whisker plots will be assigned a different color based on the Category variable using the <code>$Category_col</code> variable we created earlier.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co"># shannon diversity by year</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">bac.a.div&lt;-<span class="kw">ggplot</span>(bac.div.metadat, <span class="kw">aes</span>(<span class="dt">x=</span>Category, <span class="dt">y=</span>Bac_Shannon_Diversity, <span class="dt">fill=</span>Category)) <span class="op">+</span><span class="kw">geom_boxplot</span>(<span class="dt">color=</span><span class="st">&quot;black&quot;</span>)<span class="op">+</span><span class="kw">scale_x_discrete</span>(<span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>))<span class="op">+</span><span class="kw">theme_bw</span>()<span class="op">+</span><span class="kw">scale_fill_manual</span>( <span class="dt">values=</span><span class="kw">unique</span>(bac.div.metadat<span class="op">$</span>Category_col[<span class="kw">order</span>(bac.div.metadat<span class="op">$</span>Category)]), <span class="dt">name =</span><span class="st">&quot;Sample Category&quot;</span>, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>), )<span class="op">+</span><span class="kw">theme_classic</span>()<span class="op">+</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Bacterial Shannon Diversity by Sample Category&quot;</span>, <span class="dt">x=</span><span class="st">&quot;Category&quot;</span>, <span class="dt">y=</span><span class="st">&quot;Shannon Diversity&quot;</span>, <span class="dt">fill=</span><span class="st">&quot;Category&quot;</span>)<span class="op">+</span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>),<span class="dt">legend.title.align=</span><span class="fl">0.5</span>, <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">hjust=</span><span class="fl">0.5</span>, <span class="dt">size=</span><span class="dv">15</span>))</a>
<a class="sourceLine" id="cb31-4" data-line-number="4"></a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="kw">ggsave</span>(bac.a.div,<span class="dt">filename =</span> <span class="st">&quot;Bacterial_alpha_diversity.png&quot;</span>, <span class="dt">width=</span><span class="dv">12</span>, <span class="dt">height=</span><span class="dv">10</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/Bacterial_alpha_diversity.png" />
</center>
<div align="center">
Figure 8a: Boxplot of Alpha Diversity by Sample Category
</div>
<p></br></p>
<p>We observe the highest average Shannon diversity within the Clear Cut Soil category, followed by the Gopher category, then the No Gopher category, and the Old Growth category. Though this figure is helpful for comparing these categories to one another, we cannot really glean meaningful statistical inforamtion from this boxplot.</p>
<p>Not only does <code>ggpubr</code> help us with arranging and saving figures, but we can also use some if its functions to add statistics directly onto our figures with ease. In the next code chunk we use a function called <code>stat_compare_means()</code> which allows you to compare different sets of samples to each other. Because we have already assigned our samples to Categories, we can compare the means across our multiple samples.</p>
<p>We can compare the means of each sample to each other in a pair-wise fashion by using either a <strong>T-test</strong> (<code>t.test</code>) or a using a <strong>Wilcoxon test</strong> (<code>wilcox.test</code>), or compare the means across all of our samples at once using an <strong>Analysis of Variance</strong> aka ANOVA (<code>anova</code>) or a <strong>Kruskal-Wallis test</strong> (<code>kruskal.test</code>). For more information on how to use the <code>stat_compare_means()</code> function to add statistics to your plots, please see this <a href="http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/76-add-p-values-and-significance-levels-to-ggplots/">website</a>.</p>
<p>Deciding on whether to use a T-test verses a Wilcoxon test, or an ANOVA verses a Kruskal-Wallis test, depends on whether your data fulfills certain assumptions held by these statistical tests. One of the assumptions for a T-test and an ANOVA is that the data is <em>normally distributed</em>. We can test for normality using the <strong>Shapiro-Wilk test</strong>.</p>
<p>The null hypothesis for the Shapiro-Wilk test is that the data is normally distributed. This means that if your p-value for the Shapiro-Wilk test is &gt; 0.05, then the null hypothesis is accepted and the data is in fact normally distributed. However, if p is &lt; 0.05, then the null hypothesis is rejected and your data are not normally distributed.</p>
<p>We can also use a <strong>Q-Q plot</strong> to compare our data with a theoretical normal distribution. These plots show the quantiles for our data in the y-axis, and the theoretical quantiles for a normal distribution on the x-axis. If our data points lie on the line in the Q-Q plot, then the data is considered normally distributed. Skewed data will contain points that are further from the line, curving one way or another.</p>
<p>Let’s run a Shapiro-Wilks test using our species richness results, and use a Q-Q plot to see the distribution of these richness values.</p>
<p><strong>NOTE:</strong> diversity and richness are usually <em>not</em> normally distributed, but it’s still important to always see how the data are distributed if you plan on running statistical tests that <a href="https://www.statisticshowto.com/assumption-of-normality-test/">assume normality</a>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="co">## Using Shapiro-Wilk test for normality</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="kw">shapiro.test</span>(bac.div.metadat<span class="op">$</span>Bac_Species_Richness) <span class="co"># what is the p-value?</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3"><span class="co"># my example p-value was p-value = 0.4429</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="co"># visualize Q-Q plot for species richness</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="kw">png</span>(<span class="st">&#39;qqplot.png&#39;</span>,,<span class="dt">width =</span> <span class="dv">1000</span>, <span class="dt">height =</span> <span class="dv">900</span>, <span class="dt">res=</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7"><span class="kw">qqnorm</span>(bac.div.metadat<span class="op">$</span>Bac_Species_Richness, <span class="dt">pch =</span> <span class="dv">1</span>, <span class="dt">frame =</span> <span class="ot">FALSE</span>) </a>
<a class="sourceLine" id="cb32-8" data-line-number="8"><span class="kw">qqline</span>(bac.div.metadat<span class="op">$</span>Bac_Species_Richness, <span class="dt">col =</span> <span class="st">&quot;steelblue&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/qqplot.png" />
</center>
<div align="center">
Figure 8b: Normal Q-Q Plot: Species Richness
</div>
<p></br></p>
<p>Because our p-value for the Shapiro-Wilks test is &gt; 0.05, we’ve determined that our species richness values are not normally distributed. Because of this, we will use a Wilcoxon test (rather than a T-test) to compare the means of our sample groups in a pairwise fashion. Because we only have two groups in this example, we cannot run an Kruskal-Wallis test. Kruskal-Wallis tests and ANOVAs are used when comparing three or more groups.</p>
<p>In the boxplot below, I have only included a few pairwise group comparisons as to not overwhelm the plot. If you’d rather use <code>*</code> as indicators of statistical significance instead of using the p-values themselves, you can change the label parameter in the <code>stat_compare_means()</code> function from <code>&quot;p.format&quot;</code> to <code>&quot;p.signif&quot;</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">bac.spec.rich&lt;-<span class="kw">ggplot</span>(bac.div.metadat, <span class="kw">aes</span>(<span class="dt">x=</span>Category, <span class="dt">y=</span>Bac_Species_Richness, <span class="dt">fill=</span>Category)) <span class="op">+</span><span class="kw">geom_boxplot</span>(<span class="dt">color=</span><span class="st">&quot;black&quot;</span>)<span class="op">+</span><span class="kw">scale_x_discrete</span>(<span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>))<span class="op">+</span><span class="kw">theme_bw</span>()<span class="op">+</span><span class="kw">scale_fill_manual</span>( <span class="dt">values=</span><span class="kw">unique</span>(bac.div.metadat<span class="op">$</span>Category_col[<span class="kw">order</span>(bac.div.metadat<span class="op">$</span>Category)]), <span class="dt">name =</span><span class="st">&quot;Sample Category&quot;</span>, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>), )<span class="op">+</span><span class="kw">theme_classic</span>()<span class="op">+</span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Bacterial Species Richness by Sample Category&quot;</span>, <span class="dt">x=</span><span class="st">&quot;Category&quot;</span>, <span class="dt">y=</span><span class="st">&quot;Species Richness&quot;</span>, <span class="dt">fill=</span><span class="st">&quot;Category&quot;</span>)<span class="op">+</span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>),<span class="dt">legend.title.align=</span><span class="fl">0.5</span>, <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">hjust=</span><span class="fl">0.5</span>, <span class="dt">size=</span><span class="dv">15</span>))<span class="op">+</span><span class="kw">stat_compare_means</span>(<span class="dt">comparisons =</span> <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>)), <span class="dt">hide.ns =</span> <span class="ot">FALSE</span>,<span class="dt">label =</span> <span class="st">&quot;p.signif&quot;</span>,<span class="dt">method=</span><span class="st">&quot;wilcox.test&quot;</span>)<span class="op">+</span><span class="kw">stat_compare_means</span>(<span class="dt">label.y=</span><span class="dv">3600</span>)</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="kw">ggsave</span>(bac.spec.rich,<span class="dt">filename =</span> <span class="st">&quot;Bacterial_species_richness.png&quot;</span>, <span class="dt">width=</span><span class="dv">12</span>, <span class="dt">height=</span><span class="dv">10</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/Bacterial_species_richness.png" />
</center>
<div align="center">
Figure 8c: Boxplot of Species Richness by Sample Category
</div>
<p></br></p>
<p>I did not want to overwhelm you with multiple pairwise group comparisons on this figure, so you are only seeing the results of three Wilcoxon tests comparing Clear Cut Soil to Old Growth samples, Gopher to No Gopher samples, and No Gopher to Old Growth Samples. The <code>*</code> indicate significance levels, with <code>*</code> being <em>p &lt;= 0.05</em>, <code>**</code> being <em>p &lt;= 0.01</em>, <code>***</code> is <em>p &lt;= 0.001</em>, and <code>****</code> is <em>p &lt;= 0.0001</em>. The symbol <code>ns</code> stands for <em>not significant</em>. Figure 8c shows us that the Clear Clut Soil samples have a significantly higher average Species Richness than the Old Growth samples. We can also see that our No Gopher samples are significantly higher in species richness than the Old Growth samples, but the difference between the species richness averages in the Gopher verses No Gopher samples is not statistically significant. You can also see a printed value for the Kruskal-Wallis test, which here is p = 0.00008. This test indicates that there is a significant difference in average species richness across all of the sample categories.</p>
</div>
</div>
<div id="beta-div-section" class="section level2">
<h2><span class="header-section-number">4.3</span> Beta Diversity</h2>
<div id="data-transformation" class="section level3">
<h3><span class="header-section-number">4.3.1</span> Data Transformation</h3>
<p>Before going any further, we should transform our data. Data transformation helps us to better interpret our data by changing the scales in which we view our data, as well as reducing the impact of skewed data and/or outliers in our data set. We can also perform a transformation that normalizes our data, aka changing the distribution of our data to be a normal (i.e., Gaussian) distribution, which is useful for running certain statistical tests that assume normality (like T-tests, ANOVAs). For more on why you should transform your data and what kind of transformations are out there, check out the resources included in this very helpful <a href="https://medium.com/analytics-vidhya/a-guide-to-data-transformation-9e5fa9ae1ca3">Medium article</a>. I have also found this <a href="https://medium.com/@kyawsawhtoon/log-transformation-purpose-and-interpretation-9444b4b049c9#:~:text=Log%20transformation%20is%20a%20data,on%20the%20natural%20log%20transformation.">Medium article</a> on log transformations helpful as well.</p>
<p>Two useful transformations I have seen used are the <strong>variance stabilizing transformation</strong> (i.e, <strong>VST</strong>) and the <strong>centered log-ratio</strong> transformation (i.e, <strong>CLR</strong>). For information on how to employ this particular transformation, please check out this <a href="https://astrobiomike.github.io/amplicon/dada2_workflow_ex#beta-diversity">tutorial</a> by the legendary bioinformatician <a href="https://astrobiomike.github.io/research/">Dr. Mike Lee</a>. Though I won’t be using the VST transformation, I have not found any literature saying that the CLR transformation is better than VST. The CLR transformation appears to be popular among statisticians, which is why I am choosing to go this route.</p>
<p>We will use the <code>microbiome</code> package <span class="citation">(Lahti and Shetty 2019)</span> to CLR transform our count data for creating clustering dendrograms and ordinations. The CLR transformation is recommended in the paper “Microbiome Datasets Are Compositional: And This Is Not Optional” by <span class="citation">Gloor et al. (2017)</span>, which proposes that microbiome data sets are compositional, meaning they describe relationships between multiple components. <span class="citation">Gloor et al. (2017)</span> argues that the reason that CLR transformations are ideal for compositional data is because 1. ratio transformations are useful for detecting relationships in both count data and proportion data, and 2. because log-ratios specifically make the data symmetric in a log space.</p>
<p>A requirement for the <code>microbiome::transform</code> function is that it requires a <code>phyloseq</code> object (i.e., a type of object created by the <code>phyloseq</code> package; <span class="citation">McMurdie and Holmes (2013)</span>) as input. Let’s create our phyloseq object with our <code>bac.ASV_counts</code> matrix and add a small pseudocount to the cells in our matrix containing <code>0s</code>. It’s important to change all of the 0s to a very small number so that the log of 0 is not taken in our transformation. To better understand how CLR transformation works and why its a useful transformation for microbiome data, watch this great <a href="https://www.youtube.com/watch?v=fQPCeV4MUe4">YouTube video</a> created by <a href="https://tpq.github.io/">Dr. Thomas Quinn</a> and read “Normalization and microbial differential abundance strategies depend upon data characteristics” by <span class="citation">Weiss et al. (2017)</span>. For more information on the pros and cons of the CLR transformation, please read “A field guide for the compositional analysis of any-omics data” by <span class="citation">Quinn et al. (2019)</span>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co"># turning bac.ASV_counts into phyloseq object called ASV</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="co">## bac.ASV_counts[,-ncol(bac.ASV_counts)] allows us to drop the last column in the data frame, which in this case is a column of ASV IDs</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">ASV&lt;-<span class="kw">otu_table</span>(<span class="kw">as.matrix</span>(bac.ASV_counts[,<span class="op">-</span><span class="kw">ncol</span>(bac.ASV_counts)]), <span class="dt">taxa_are_rows =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="kw">head</span>(ASV)</a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="kw">class</span>(ASV) <span class="co"># phyloseq otu_table object</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="co"># add pseudocount bfore transformation!</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">ASV[ASV<span class="op">==</span><span class="dv">0</span>]&lt;-<span class="fl">0.001</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9"><span class="kw">head</span>(ASV)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10"></a>
<a class="sourceLine" id="cb34-11" data-line-number="11"><span class="co"># CLR transformation on phyloseq object</span></a>
<a class="sourceLine" id="cb34-12" data-line-number="12">asv_clr&lt;-microbiome<span class="op">::</span><span class="kw">transform</span>(ASV, <span class="st">&quot;clr&quot;</span>)</a>
<a class="sourceLine" id="cb34-13" data-line-number="13"><span class="kw">head</span>(asv_clr)</a></code></pre></div>
</div>
<div id="hierarchical-clustering" class="section level3">
<h3><span class="header-section-number">4.3.2</span> Hierarchical Clustering</h3>
<p>Now that we have our transformed ASV counts, we can create a Euclidean distance matrix that will describe how close (aka similar) our samples are to each other based on their microbial composition. The Euclidean distance between CLR-Transformed compositional data is known as <strong>Aitchison Distance</strong> <span class="citation">(Quinn et al. 2018)</span>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="co"># create CLR Sample x Species matrix for input into dist()</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">b.clr&lt;-<span class="kw">as.matrix</span>(<span class="kw">t</span>(asv_clr))</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="co"># calculate our Euclidean distance matrix using CLR data (aka Aitchison distance)</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5">b.euc_dist &lt;-<span class="st"> </span><span class="kw">dist</span>(b.clr, <span class="dt">method =</span> <span class="st">&quot;euclidean&quot;</span>)</a>
<a class="sourceLine" id="cb35-6" data-line-number="6"></a>
<a class="sourceLine" id="cb35-7" data-line-number="7"><span class="co"># creating our hierarcical clustering dendrogram</span></a>
<a class="sourceLine" id="cb35-8" data-line-number="8">b.euc_clust &lt;-<span class="st"> </span><span class="kw">hclust</span>(b.euc_dist, <span class="dt">method=</span><span class="st">&quot;ward.D2&quot;</span>)</a>
<a class="sourceLine" id="cb35-9" data-line-number="9"></a>
<a class="sourceLine" id="cb35-10" data-line-number="10"><span class="co"># let&#39;s make it a little nicer...</span></a>
<a class="sourceLine" id="cb35-11" data-line-number="11">b.euc_dend &lt;-<span class="st"> </span><span class="kw">as.dendrogram</span>(b.euc_clust, <span class="dt">hang=</span><span class="fl">0.1</span>)</a>
<a class="sourceLine" id="cb35-12" data-line-number="12">b.dend_cols &lt;-<span class="st"> </span><span class="kw">as.character</span>(metadata<span class="op">$</span>Category_col[<span class="kw">order.dendrogram</span>(b.euc_dend)])</a>
<a class="sourceLine" id="cb35-13" data-line-number="13"><span class="kw">labels_colors</span>(b.euc_dend) &lt;-<span class="st"> </span>b.dend_cols</a>
<a class="sourceLine" id="cb35-14" data-line-number="14"></a>
<a class="sourceLine" id="cb35-15" data-line-number="15"><span class="kw">png</span>(<span class="dt">file=</span><span class="st">&quot;16S_CLR_cluster_Category.png&quot;</span>,<span class="dt">width =</span> <span class="dv">1000</span>, <span class="dt">height =</span> <span class="dv">900</span>, <span class="dt">res=</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb35-16" data-line-number="16"><span class="kw">par</span>(<span class="dt">cex=</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb35-17" data-line-number="17"><span class="kw">plot</span>(b.euc_dend, <span class="dt">ylab=</span><span class="st">&quot;CLR Euclidean Distance&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">title</span>(<span class="dt">main =</span> <span class="st">&quot;Bacteria/Archaea Clustering Dendrogram&quot;</span>, <span class="dt">sub =</span> <span class="st">&quot;Colored by Sample Category&quot;</span>, <span class="dt">cex.main =</span> <span class="dv">2</span>, <span class="dt">font.main=</span> <span class="dv">2</span>, <span class="dt">cex.sub =</span> <span class="fl">0.8</span>, <span class="dt">font.sub =</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb35-18" data-line-number="18"><span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>,<span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;Old Growth&quot;</span>),<span class="dt">cex=</span>.<span class="dv">8</span>,<span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;#D00000&quot;</span>, <span class="st">&quot;#f8961e&quot;</span>, <span class="st">&quot;#4ea8de&quot;</span>, <span class="st">&quot;#283618&quot;</span>),<span class="dt">pch =</span> <span class="dv">15</span>, <span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>)</a>
<a class="sourceLine" id="cb35-19" data-line-number="19"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_CLR_cluster_Category.png" />
</center>
<div align="center">
Figure 9: Hierarchical Clustering (with Centered Log-Ratio Transformed Data)
</div>
<p></br></p>
<p>Though there are some samples not clustered within their sample categories, overall it appears that samples from specific categories form distinct clusters. This indicates thats generally, samples from the same category have similar microbial community composition. We can also see that most of the samples in the Clear Cut Soil category are more similar to the Gopher and No Gopher samples compared to the Old Growth samples. Though this dendogram is helpful, it’s not as informative as other visualizations we can do.</p>
</div>
<div id="principal-coordinate-analysis-pcoa" class="section level3">
<h3><span class="header-section-number">4.3.3</span> Principal Coordinate Analysis (PCoA)</h3>
<p>To learn more about how these sample categories’ microbiomes compare to one another, we can use our Euclidean distance matrix (created from CLR transformed ASV counts) to generate an ordination known as <strong>Principal Coordinate Analysis</strong>, aka a <strong>PCoA</strong>.</p>
<p>I am not going to get into the math behind a PCoA, but you can learn more by watching this excellent <a href="https://youtu.be/GEn-_dAyYME">StatQuest YouTube video</a> and this helpful <a href="https://mb3is.megx.net/gustame/dissimilarity-based-methods/principal-coordinates-analysis">link</a> that describes what a PCoA is and its uses. If you’re interested in learning more about ordinations in general and the impacts they can have on microbiome data, please read “Uncovering the Horseshoe Effect in Microbial Analyses” by <span class="citation">Morton et al. (2017)</span>.</p>
<p>Generally a PCoA is used at looking at how similar your samples are to each other, and the variability exhibited by your samples, in a reduced dimensional space. The closer two points are in your ordination, the more similar they are. PCoAs yield multiple axes (i.e., principal components) that capture the variation within your data set and are associated with certain values (i.e., <strong>eigenvalues</strong>) that represent to the magnitude of the variation for each axis. These eigenvalues are relative representations of how important each axis of variation is for describing the data set.</p>
<p>PCoAs were developed so that we can create these ordinations using distances that are NOT Euclidean, for example like Bray-Curtis dissimilarity distances. PCoAs come from <strong>Principal Component Analysis</strong>, which is specifically used for Euclidean distances. For more information on PCAs, check out this <a href="https://youtu.be/FgakZw6K1QQ">StatQuest YouTube video</a> as well as this <a href="https://ourcodingclub.github.io/tutorials/ordination/">tutorial</a> that compares PCAs to PCoAs.</p>
<p>Let’s generate our PCoA and a PCA and check out the proportion of variance explained by our axes. The reason I am showing you how to generate both is because a PCoA using Euclidean distances is equivalent to a PCA. This is a useful way to confirm that our data is actually Euclidean in nature.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co"># let&#39;s use our Euclidean distance matrix from before to generate a PCoA</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">b.pcoa &lt;-<span class="st"> </span><span class="kw">pcoa</span>(b.euc_dist)</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="co"># Variance explained by each axis is the Relative eigen (values$Relative_eig)</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">b.pcoa<span class="op">$</span>values<span class="op">$</span>Relative_eig</a>
<a class="sourceLine" id="cb36-5" data-line-number="5"></a>
<a class="sourceLine" id="cb36-6" data-line-number="6">b.pca =<span class="st"> </span><span class="kw">prcomp</span>(b.clr)</a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="co"># Variance explained by each axis is the Proportion of Variance</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">b.pca.sum&lt;-<span class="kw">summary</span>(b.pca)</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">b.pca.sum<span class="op">$</span>importance </a></code></pre></div>
<p>The first axis (PC1) of variation describes 8.94% of the variance in the entire data set. The second axis (PC2) describes 5.69% of the variation. Our PC axes generated by our PCoA are equivalent to our axes generated by the PCA, which is to be expected using Euclidean distances. The first 2-3 axes describe the greatest amount of variation in the data set, and are included in the visualization of the PCoA.</p>
<p>To visualize our PCoA with <code>ggplot2</code>, we have to extract the principal coordinates for each sample across our axes of variation and combine these values with our metadata. Then we can make a PCoA ordination and color each sample ID with our variable of interest (in this case, the Sample Category, aka <code>metadata$Category</code>). We can also include the relative variation for each axis in our x-axis and y-axis labels.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co"># extract principal coordinates</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">b.pcoa.vectors&lt;-<span class="kw">data.frame</span>(b.pcoa<span class="op">$</span>vectors)</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">b.pcoa.vectors<span class="op">$</span>SampleID&lt;-<span class="kw">rownames</span>(b.pcoa<span class="op">$</span>vectors)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4"></a>
<a class="sourceLine" id="cb37-5" data-line-number="5"><span class="co"># merge pcoa coordinates w/ metadata</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">b.pcoa.meta&lt;-<span class="kw">merge</span>(b.pcoa.vectors, metadata, <span class="dt">by.x=</span><span class="st">&quot;SampleID&quot;</span>, <span class="dt">by.y=</span><span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb37-7" data-line-number="7"><span class="kw">head</span>(b.pcoa.meta)</a>
<a class="sourceLine" id="cb37-8" data-line-number="8"></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">b.pcoa<span class="op">$</span>values<span class="op">$</span>Relative_eig <span class="co"># pull out relative variation % to add to axes labels</span></a>
<a class="sourceLine" id="cb37-10" data-line-number="10"></a>
<a class="sourceLine" id="cb37-11" data-line-number="11"><span class="co"># create PCoA ggplot fig</span></a>
<a class="sourceLine" id="cb37-12" data-line-number="12">pcoa1&lt;-<span class="kw">ggplot</span>(b.pcoa.meta, <span class="kw">aes</span>(<span class="dt">x=</span>Axis<span class="fl">.1</span>, <span class="dt">y=</span>Axis<span class="fl">.2</span>)) <span class="op">+</span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color=</span><span class="kw">factor</span>(Category)), <span class="dt">size=</span><span class="dv">4</span>)<span class="op">+</span><span class="kw">theme_bw</span>()<span class="op">+</span><span class="kw">labs</span>(<span class="dt">title=</span><span class="st">&quot;PCoA: Bacteria/Archaea&quot;</span>,<span class="dt">subtitle=</span><span class="st">&quot;Using Centered-Log Ratio Data&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;Axis 1&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Axis 2&quot;</span>,<span class="dt">color=</span><span class="st">&quot;Sample Category&quot;</span>)<span class="op">+</span><span class="kw">theme_classic</span>()<span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">15</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">15</span>),<span class="dt">legend.title.align=</span><span class="fl">0.5</span>, <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">15</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">12</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>),<span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">12</span>),,<span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">17</span>))<span class="op">+</span><span class="kw">guides</span>(<span class="dt">shape =</span> <span class="kw">guide_legend</span>(<span class="dt">override.aes =</span> <span class="kw">list</span>(<span class="dt">size =</span> <span class="dv">5</span>)))<span class="op">+</span><span class="kw">scale_color_manual</span>(<span class="dt">name =</span><span class="st">&quot;Sample Category&quot;</span>, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>),<span class="dt">values=</span><span class="kw">unique</span>(b.pcoa.meta<span class="op">$</span>Category_col[<span class="kw">order</span>(b.pcoa.meta<span class="op">$</span>Category)])) <span class="op">+</span><span class="kw">xlab</span>(<span class="st">&quot;Axis 1 [8.94%]&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Axis 2 [5.69%]&quot;</span>)</a>
<a class="sourceLine" id="cb37-13" data-line-number="13"></a>
<a class="sourceLine" id="cb37-14" data-line-number="14"><span class="kw">ggsave</span>(pcoa1,<span class="dt">filename =</span> <span class="st">&quot;16S_pcoa_CLR.png&quot;</span>, <span class="dt">width=</span><span class="dv">12</span>, <span class="dt">height=</span><span class="dv">10</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_pcoa_CLR.png" />
</center>
<div align="center">
Figure 10: Principal Coordinates Analysis, Colored by Sample Category
</div>
<p></br></p>
<p>From this PCoA we can tell that the microbial community composition in the Old Growth samples are similar to one another, forming a tight cluster in the PCoA (points in dark green). The microbial composition of the Clear Cut Soil samples are also similar to one another (points in red). Interestingly, the Gopher and No Gopher samples cluster together, indicating that their microbial communities are similar to each other, regardless of whether a gopher was introduced to the soil or not. It is important to keep in mind that though we see distinct clusters by sample category, the variation explained by this variable is quite low (Axis 1 - 8.94%, Axis 2 - 5.59%).</p>
<p>So this information is helpful, but we are not sure if our categories are significantly similar/dissimilar from each other. To do this, we first need to check the dispersion (aka variance) of the composition data within each group to see if we can even compare these groups to each other. Basically we are finding the spatial median or the <em>centroid</em> of each group in multivariate space, and calculating the distance from each point to the centroid within a respective group or category. The actual distances are reduced to principal coordinates (as is done in a PCA or PCoA) before the distances from each group are compared. We then can use an ANOVA as well as a <strong>Tukey’s Honest Signifcant Difference Test</strong> (aka Tukey’s HSD) to statistically compare the group dispersions.</p>
<p>To check out our group dispersions and whether or not they are homogeneous (equal/similar to each other in their variance), we will use the <code>betadisper()</code> function from the <code>vegan</code> package. We can then compare the axes of dispersion with the <code>anova()</code> function and compare the spatial means with the <code>TukeyHSD()</code> function.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co"># create CLR Sample x Species matrix for input into dist()</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">b.clr&lt;-<span class="kw">as.matrix</span>(<span class="kw">t</span>(asv_clr))</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">rownames</span>(b.clr)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="kw">rownames</span>(metadata)</a>
<a class="sourceLine" id="cb38-5" data-line-number="5"><span class="co"># reorder the transformed ASV table to match order of metadata data frame</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6">b.clr=b.clr[<span class="kw">rownames</span>(metadata),] <span class="co"># reorder both dfs by row names</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7"><span class="co"># sanity check</span></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="kw">rownames</span>(b.clr)</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="kw">rownames</span>(metadata)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10"></a>
<a class="sourceLine" id="cb38-11" data-line-number="11"><span class="co"># calculate our Euclidean distance matrix using CLR data (aka Aitchison distance)</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">b.euc_dist &lt;-<span class="st"> </span><span class="kw">dist</span>(b.clr, <span class="dt">method =</span> <span class="st">&quot;euclidean&quot;</span>)</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">b.disper&lt;-<span class="kw">betadisper</span>(b.euc_dist, metadata<span class="op">$</span>Category)</a>
<a class="sourceLine" id="cb38-14" data-line-number="14">b.disper</a>
<a class="sourceLine" id="cb38-15" data-line-number="15"></a>
<a class="sourceLine" id="cb38-16" data-line-number="16"><span class="kw">permutest</span>(b.disper, <span class="dt">pairwise=</span><span class="ot">TRUE</span>) <span class="co"># compare dispersions to each other via permutation test to see significant differences in dispersion by pairwise comparisons</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17"></a>
<a class="sourceLine" id="cb38-18" data-line-number="18"><span class="kw">anova</span>(b.disper) <span class="co"># p = 0.0001394 --&gt; reject the Null H, spatial medians are significantly difference across Categories</span></a>
<a class="sourceLine" id="cb38-19" data-line-number="19"></a>
<a class="sourceLine" id="cb38-20" data-line-number="20"><span class="kw">TukeyHSD</span>(b.disper) <span class="co"># tells us which Category&#39;s dispersion MEANS are significantly different than each other</span></a></code></pre></div>
<p>The ANOVA results tell us that our dispersions by category are significantly different than each other (p=0.0001394), meaning the variance within each category is not homogenous. We can visualize this comparison as well via an ordination (calculated by <code>betadisper()</code>) and a boxplot based on the distance to the centroid for each group.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co"># Visualize dispersions</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="kw">png</span>(<span class="st">&#39;pcoa_betadispersion.png&#39;</span>,<span class="dt">width =</span> <span class="dv">700</span>, <span class="dt">height =</span> <span class="dv">600</span>, <span class="dt">res=</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="kw">plot</span>(b.disper,<span class="dt">main =</span> <span class="st">&quot;Centroids and Dispersion based on Aitchison Distance&quot;</span>, <span class="dt">col=</span>colorset1<span class="op">$</span>Category_col)</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/pcoa_betadispersion.png" />
</center>
<div align="center">
Figure 11a: Principal Coordinates Analysis w/ <code>betadisper()</code>. Colored by Sample Category
</div>
<p></br></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">png</span>(<span class="st">&#39;boxplot_centroid_distance.png&#39;</span>,<span class="dt">width =</span> <span class="dv">700</span>, <span class="dt">height =</span> <span class="dv">600</span>, <span class="dt">res=</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="kw">boxplot</span>(b.disper,<span class="dt">xlab=</span><span class="st">&quot;Sample Category&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Distance to Centroid by Category&quot;</span>, <span class="dt">sub=</span><span class="st">&quot;Based on Aitchison Distance&quot;</span>, <span class="dt">names=</span><span class="kw">c</span>(<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;Old Growth&quot;</span>), <span class="dt">col=</span>colorset1<span class="op">$</span>Category_col)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/boxplot_centroid_distance.png" />
</center>
<div align="center">
Figure 11b: Distance to Centroid of Dispersion. Colored by Sample Category
</div>
<p></br></p>
<p>The reason that our dispersion results are problematic is that if we try to compare the groups using a <strong>Permutational Analysis of Variance</strong> (aka a <strong>PERMANOVA</strong>), the significant differences we may see between groups could be attributed to their unequal variances (i.e., dispersion effects) rather than actual differences in the community compositions by category.</p>
</div>
<div id="permanova-w-aitchison-distance" class="section level3">
<h3><span class="header-section-number">4.3.4</span> PERMANOVA w/ Aitchison Distance</h3>
<p>A PERMANOVA is similar to an ANOVA in that both analyses compare differences between groups (using <em>sum-of-squares</em>), but a PERMANOVA runs multiple permutations to compare these <em>distances</em> to each other - whereas an ANOVA is comparing group <em>averages</em> to each other without the use of permutations. Another difference is that while ANOVAs assume that the data is normally distributed, the PERMANOVA assumes that the groups have equal variance (dispersion). For more information on PERMANOVAs and comparing group variances, check out this very helpful <a href="https://archetypalecology.wordpress.com/2018/02/21/permutational-multivariate-analysis-of-variance-permanova-in-r-preliminary/">link</a> by <a href="https://scholar.google.com/citations?user=0U4m9BUAAAAJ&amp;hl=en">Dr. Joshua Ebner</a>.</p>
<p>Even though we should not run a PERMANOVA with these data, let’s go over how we would run a PERMANVOA. <strong>The most crucial thing about running a PERMANOVA in R is that your feature table and your metadata need to be in the same order by row!</strong> The program does not know to match up sample IDs or labels to each other, so you have to confirm that your data frames are arranged in the same way by row before running the PERMANOVA. We can then run our PERMANOVA including multiple variables of interest. We can see if there are interactions between multiple variables and our compositional data respectively with <code>+</code> (i.e, <code>var1 + var2</code>), or we can check for interactions between our variables and our composition data with <code>*</code> (i.e, <code>var1 * var2</code>).</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="co"># check your rownames and the order of the rownames for ordering step</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="kw">rownames</span>(b.clr)</a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="kw">rownames</span>(metadata)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="co"># in case you need to reorder</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5">b.clr=b.clr[<span class="kw">rownames</span>(metadata),]</a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="co"># sanity check</span></a>
<a class="sourceLine" id="cb41-7" data-line-number="7"><span class="kw">rownames</span>(b.clr)</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"><span class="kw">rownames</span>(metadata)</a>
<a class="sourceLine" id="cb41-9" data-line-number="9"></a>
<a class="sourceLine" id="cb41-10" data-line-number="10"><span class="co"># PERMANOVA requires assumption of homogenous within-group disperions to ensure observed differences in groups are real</span></a>
<a class="sourceLine" id="cb41-11" data-line-number="11">perm1&lt;-<span class="kw">adonis2</span>(b.clr <span class="op">~</span><span class="st"> </span>Category, <span class="dt">data =</span> metadata, <span class="dt">permutations =</span> <span class="dv">999</span>, <span class="dt">method=</span><span class="st">&quot;euclid&quot;</span>, <span class="dt">by=</span><span class="st">&#39;terms&#39;</span>) <span class="co"># looks for interactions between predictor variables</span></a>
<a class="sourceLine" id="cb41-12" data-line-number="12">perm1</a>
<a class="sourceLine" id="cb41-13" data-line-number="13"></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">perm2&lt;-<span class="kw">adonis2</span>(b.clr <span class="op">~</span><span class="st"> </span>Category<span class="op">*</span>layer, <span class="dt">data =</span> metadata, <span class="dt">permutations =</span> <span class="dv">999</span>, <span class="dt">method=</span><span class="st">&quot;euclid&quot;</span>, <span class="dt">by=</span><span class="st">&#39;terms&#39;</span>)</a>
<a class="sourceLine" id="cb41-15" data-line-number="15"><span class="co"># * -&gt; for interactions between predictor variables; + -&gt; interactions with multiple variables but not between them or combined interactions</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16">perm2</a>
<a class="sourceLine" id="cb41-17" data-line-number="17"><span class="kw">adonis2</span>(b.clr <span class="op">~</span><span class="st"> </span>Category<span class="op">+</span>layer, <span class="dt">data =</span> metadata, <span class="dt">permutations =</span> <span class="dv">999</span>, <span class="dt">method=</span><span class="st">&quot;euclid&quot;</span>, <span class="dt">by=</span><span class="st">&#39;terms&#39;</span>)</a>
<a class="sourceLine" id="cb41-18" data-line-number="18"></a>
<a class="sourceLine" id="cb41-19" data-line-number="19"><span class="co"># export PERMANOVA results to csv</span></a>
<a class="sourceLine" id="cb41-20" data-line-number="20">perm1_results&lt;-<span class="kw">data.frame</span>(<span class="dt">DF=</span>perm1<span class="op">$</span>Df, <span class="dt">SumofSqs=</span>perm1<span class="op">$</span>SumOfSqs, <span class="dt">R2=</span>perm1<span class="op">$</span>R2, <span class="dt">F=</span>perm1<span class="op">$</span>F, <span class="dt">p=</span>perm1<span class="op">$</span><span class="st">`</span><span class="dt">Pr(&gt;F)</span><span class="st">`</span>)</a>
<a class="sourceLine" id="cb41-21" data-line-number="21"><span class="kw">rownames</span>(perm1_results)&lt;-<span class="kw">rownames</span>(perm1)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">perm1_results</a>
<a class="sourceLine" id="cb41-23" data-line-number="23"><span class="kw">write.csv</span>(perm1_results,<span class="st">&quot;16S_PERMANOVA_Results.csv&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb41-24" data-line-number="24"></a>
<a class="sourceLine" id="cb41-25" data-line-number="25"><span class="co"># save PERMANOVA results in a nice table</span></a>
<a class="sourceLine" id="cb41-26" data-line-number="26">tab &lt;-<span class="st"> </span><span class="kw">ggtexttable</span>(perm1_results, <span class="dt">theme =</span> <span class="kw">ttheme</span>(<span class="st">&quot;light&quot;</span>))</a>
<a class="sourceLine" id="cb41-27" data-line-number="27">tab2&lt;-<span class="st"> </span>tab <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb41-28" data-line-number="28"><span class="st">  </span><span class="kw">tab_add_title</span>(<span class="dt">text =</span> <span class="st">&quot;PERMANOVA Results: Composition ~ Category&quot;</span>, <span class="dt">face =</span> <span class="st">&quot;bold&quot;</span>, <span class="dt">padding =</span> <span class="kw">unit</span>(<span class="dv">1</span>, <span class="st">&quot;line&quot;</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb41-29" data-line-number="29"><span class="st">  </span><span class="kw">tab_add_footnote</span>(<span class="dt">text =</span> <span class="st">&quot;Using Euclidean Distance of CLR-Transformed Data (Aitchison Distance)&quot;</span>, <span class="dt">size =</span> <span class="dv">10</span>, <span class="dt">face =</span> <span class="st">&quot;italic&quot;</span>)</a>
<a class="sourceLine" id="cb41-30" data-line-number="30"></a>
<a class="sourceLine" id="cb41-31" data-line-number="31"><span class="co"># save table as png</span></a>
<a class="sourceLine" id="cb41-32" data-line-number="32"><span class="kw">png</span>(<span class="st">&#39;permanova_table_test.png&#39;</span>,<span class="dt">width =</span> <span class="dv">700</span>, <span class="dt">height =</span> <span class="dv">600</span>, <span class="dt">res=</span><span class="dv">200</span>)</a>
<a class="sourceLine" id="cb41-33" data-line-number="33">tab2</a>
<a class="sourceLine" id="cb41-34" data-line-number="34"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/permanova_results_screenshot.png" />
</center>
<div align="center">
Figure 12: Table of PERMANOVA Results (by Category)
</div>
<p></br></p>
<p>As predicted by the <code>betadisper()</code> results, we are seeing a significant difference in community composition between our groups. Again, for this data set we can’t really know if these differences are meaningful because the within-group disperions (aka variances) are NOT homogenous - so the significance we are seeing here is likely due to dispersion effects rather than real differences between groups.</p>
</div>
</div>
<div id="relative-abundance" class="section level2">
<h2><span class="header-section-number">4.4</span> Relative Abundance</h2>
<p>So we know our microbial communities are similar to each other if they’re from the same sample category, and that the microbiomes from each category are quite different from each other…but what about the actual taxa within those communities? Calculating the relative abundance allows us to determine how abundant certain taxa are compared to the rest of the taxa within a specific sample. In order to get a better sense of the microbial community in our samples, we need to calculate the relative abundance at varying taxonomic levels. We can also calculate the relative abundance by group; for example, we can determine the relative contribution of taxa 1 compared to the rest of the microbial commiunity in Group A.</p>
<p>Let’s merge our ASV taxonomy table to our metadata table. This will help us create a data frame that we can use to get the sum of our ASV counts across specific taxonomic levels.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1">bac.all&lt;-<span class="kw">merge</span>(bac.ASV_counts, bac.ASV_tax, <span class="dt">by=</span><span class="st">&quot;ASV_ID&quot;</span>)</a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="kw">head</span>(bac.all)</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">bac_melt&lt;-<span class="kw">melt</span>(bac.all, <span class="dt">id.vars =</span> <span class="kw">c</span>(<span class="st">&quot;ASV_ID&quot;</span>, <span class="st">&quot;Kingdom&quot;</span>, <span class="st">&quot;Phylum&quot;</span>, <span class="st">&quot;Class&quot;</span>, <span class="st">&quot;Order&quot;</span>, <span class="st">&quot;Family&quot;</span>, <span class="st">&quot;Genus&quot;</span>, <span class="st">&quot;Species&quot;</span>))</a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="kw">head</span>(bac_melt)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5"><span class="kw">names</span>(bac_melt)[<span class="kw">which</span>(<span class="kw">names</span>(bac_melt) <span class="op">==</span><span class="st"> &quot;variable&quot;</span>)] &lt;-<span class="st"> &quot;SampleID&quot;</span></a>
<a class="sourceLine" id="cb42-6" data-line-number="6"><span class="kw">names</span>(bac_melt)[<span class="kw">which</span>(<span class="kw">names</span>(bac_melt) <span class="op">==</span><span class="st"> &quot;value&quot;</span>)] &lt;-<span class="st"> &quot;Counts&quot;</span></a>
<a class="sourceLine" id="cb42-7" data-line-number="7"><span class="kw">head</span>(bac_melt)</a>
<a class="sourceLine" id="cb42-8" data-line-number="8"></a>
<a class="sourceLine" id="cb42-9" data-line-number="9"><span class="kw">head</span>(metadata)</a>
<a class="sourceLine" id="cb42-10" data-line-number="10"></a>
<a class="sourceLine" id="cb42-11" data-line-number="11">all_bac&lt;-<span class="kw">merge</span>(bac_melt, metadata, <span class="dt">by =</span> <span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb42-12" data-line-number="12"><span class="kw">head</span>(all_bac) <span class="co"># contains metadata, ASV counts, and taxonomic IDs for ASVs</span></a></code></pre></div>
<p>Using the <code>all_bac</code> data frame containing our data and metadata altogether and the <code>dcast()</code> function from the <code>reshape2</code> package [], we can create data frames that contain counts by taxonomic levels. We will then use these data frames to get the relative abundance at specific taxonomic levels. Because I am using a bacterial data set, I am only going to calculate the relative abundance at the phyla and class levels. Though we could get deeper taxonomic resolution, the visualization at these levels can be really overwhelming because there are SO many taxa present.</p>
<p>Remember that when calculating your relative abundance, each count per taxa in each sample is divided by the sum of all the counts for that sample. This means that when you sum up all of the relativized values for each sample, they should sum up to 1. We can use this fact to help us check whether our relativization worked.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co"># use dcast to count up ASVs within each Phylum across all of the samples</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">b.phyla_counts &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">dcast</span>(all_bac, SampleID<span class="op">~</span>Phylum, <span class="dt">value.var=</span><span class="st">&quot;Counts&quot;</span>, <span class="dt">fun.aggregate=</span>sum)) <span class="co">###</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="kw">head</span>(b.phyla_counts) <span class="co"># counts by phyla per sample</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="kw">rownames</span>(b.phyla_counts)&lt;-b.phyla_counts<span class="op">$</span>SampleID</a>
<a class="sourceLine" id="cb43-5" data-line-number="5"></a>
<a class="sourceLine" id="cb43-6" data-line-number="6">b.phyla_RelAb&lt;-<span class="kw">data.frame</span>(<span class="kw">decostand</span>(b.phyla_counts[,<span class="op">-</span><span class="dv">1</span>], <span class="dt">method=</span><span class="st">&quot;total&quot;</span>, <span class="dt">MARGIN=</span><span class="dv">1</span>, <span class="dt">na.rm=</span><span class="ot">TRUE</span>))  </a>
<a class="sourceLine" id="cb43-7" data-line-number="7"><span class="co"># relative abundance of taxa data where everything is divided by col total (b/c Margin=1 meaning rows == SAMPLES in this case)</span></a>
<a class="sourceLine" id="cb43-8" data-line-number="8"><span class="kw">rowSums</span>(b.phyla_RelAb) <span class="co"># sanity check to make sure the transformation worked! All rowsums should = 1</span></a>
<a class="sourceLine" id="cb43-9" data-line-number="9"></a>
<a class="sourceLine" id="cb43-10" data-line-number="10">b.phyla_RelAb<span class="op">$</span>SampleID&lt;-<span class="kw">rownames</span>(b.phyla_RelAb)</a>
<a class="sourceLine" id="cb43-11" data-line-number="11"><span class="kw">head</span>(b.phyla_RelAb)</a>
<a class="sourceLine" id="cb43-12" data-line-number="12"><span class="kw">write.csv</span>(b.phyla_RelAb,<span class="st">&quot;16S_Phyla_Relative_Abundance.csv&quot;</span>,<span class="dt">row.names=</span><span class="ot">TRUE</span>) <span class="co"># good to save just in case</span></a>
<a class="sourceLine" id="cb43-13" data-line-number="13"></a>
<a class="sourceLine" id="cb43-14" data-line-number="14"><span class="co"># melt down relativized data to merge with metadata</span></a>
<a class="sourceLine" id="cb43-15" data-line-number="15">b.phyla_m&lt;-<span class="kw">melt</span>(b.phyla_RelAb)</a>
<a class="sourceLine" id="cb43-16" data-line-number="16"></a>
<a class="sourceLine" id="cb43-17" data-line-number="17"><span class="kw">head</span>(b.phyla_m)</a>
<a class="sourceLine" id="cb43-18" data-line-number="18"><span class="kw">colnames</span>(b.phyla_m)[<span class="kw">which</span>(<span class="kw">names</span>(b.phyla_m) <span class="op">==</span><span class="st"> &quot;variable&quot;</span>)] &lt;-<span class="st"> &quot;Phylum&quot;</span></a>
<a class="sourceLine" id="cb43-19" data-line-number="19"><span class="kw">colnames</span>(b.phyla_m)[<span class="kw">which</span>(<span class="kw">names</span>(b.phyla_m) <span class="op">==</span><span class="st"> &quot;value&quot;</span>)] &lt;-<span class="st"> &quot;Counts&quot;</span></a>
<a class="sourceLine" id="cb43-20" data-line-number="20"><span class="kw">head</span>(b.phyla_m) <span class="co">## relative abundance based on sum of counts by phyla!</span></a>
<a class="sourceLine" id="cb43-21" data-line-number="21"></a>
<a class="sourceLine" id="cb43-22" data-line-number="22">b.phyla_RA_meta&lt;-<span class="kw">merge</span>(b.phyla_m,metadata, <span class="dt">by=</span><span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb43-23" data-line-number="23"><span class="kw">head</span>(b.phyla_RA_meta) <span class="co">## relative abundance based on sum of counts by phyla!</span></a></code></pre></div>
<p>Now that we have our relativized phyla counts, let’s visualize the relativized counts by phyla using a stacked barplot.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1">b.phy_RA&lt;-<span class="kw">ggplot</span>(b.phyla_RA_meta, <span class="kw">aes</span>(<span class="dt">x=</span>SampleID, <span class="dt">y=</span>Counts, <span class="dt">fill=</span>Phylum))<span class="op">+</span><span class="kw">geom_bar</span>(<span class="dt">stat=</span><span class="st">&quot;identity&quot;</span>,<span class="dt">colour=</span><span class="st">&quot;black&quot;</span>)<span class="op">+</span><span class="kw">scale_x_discrete</span>()<span class="op">+</span><span class="kw">theme_classic</span>()<span class="op">+</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Microbial Phylum Relative Abundance&quot;</span>, <span class="dt">x=</span><span class="st">&quot;SampleID&quot;</span>, <span class="dt">y=</span><span class="st">&quot;Relative Abundance&quot;</span>, <span class="dt">fill=</span><span class="st">&quot;Phylum&quot;</span>)<span class="op">+</span></a>
<a class="sourceLine" id="cb44-3" data-line-number="3"><span class="st">  </span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>,<span class="dt">angle=</span><span class="dv">90</span>),<span class="dt">legend.title.align=</span><span class="fl">0.5</span>, <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">15</span>))</a>
<a class="sourceLine" id="cb44-4" data-line-number="4"></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"><span class="kw">ggsave</span>(b.phy_RA,<span class="dt">filename =</span> <span class="st">&quot;16S_phyla_RA.png&quot;</span>, <span class="dt">width=</span><span class="dv">17</span>, <span class="dt">height=</span><span class="dv">10</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_phyla_RA.png" />
</center>
<div align="center">
Figure 13: Relative Abundance by Phyla Across Samples
</div>
<p></br></p>
<p>We can see that across samples, the two most relatively abundant phyla are Abditibacteriota in coral, and Proteobacteria in light purple. Though this is helpful, it’s hard to determine which categories our samples belong to.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">head</span>(all_bac)</a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="co"># by class + elevation</span></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">bac.cls &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">dcast</span>(all_bac,SampleID<span class="op">~</span>Class, <span class="dt">value.var=</span><span class="st">&quot;Counts&quot;</span>, <span class="dt">fun.aggregate=</span>sum)) <span class="co">### </span></a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="kw">head</span>(bac.cls) <span class="co"># counts by class + elevation</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5"><span class="kw">rownames</span>(bac.cls)&lt;-bac.cls<span class="op">$</span>SampleID</a>
<a class="sourceLine" id="cb45-6" data-line-number="6"></a>
<a class="sourceLine" id="cb45-7" data-line-number="7">b.RA_cls&lt;-<span class="kw">data.frame</span>(<span class="kw">decostand</span>(bac.cls[,<span class="op">-</span><span class="dv">1</span>], <span class="dt">method=</span><span class="st">&quot;total&quot;</span>, <span class="dt">MARGIN=</span><span class="dv">1</span>, <span class="dt">na.rm=</span><span class="ot">TRUE</span>))  </a>
<a class="sourceLine" id="cb45-8" data-line-number="8"><span class="co"># relative abundance of taxa data where everything is divided by margin total (default MARGIN = 1 = rows) -- rows = samples</span></a>
<a class="sourceLine" id="cb45-9" data-line-number="9"><span class="co"># bac.cls.cat[,-1] -- drop first column to not be included in relative abundance calculation</span></a>
<a class="sourceLine" id="cb45-10" data-line-number="10"></a>
<a class="sourceLine" id="cb45-11" data-line-number="11"><span class="kw">rowSums</span>(b.RA_cls) <span class="co"># sanity check</span></a>
<a class="sourceLine" id="cb45-12" data-line-number="12">b.RA_cls<span class="op">$</span>SampleID&lt;-<span class="kw">rownames</span>(b.RA_cls)</a>
<a class="sourceLine" id="cb45-13" data-line-number="13"><span class="kw">head</span>(b.RA_cls)</a>
<a class="sourceLine" id="cb45-14" data-line-number="14"></a>
<a class="sourceLine" id="cb45-15" data-line-number="15"><span class="co">#melt down relativized data to merge with metadata</span></a>
<a class="sourceLine" id="cb45-16" data-line-number="16">b.cls_m&lt;-<span class="kw">melt</span>(b.RA_cls, <span class="dt">by=</span><span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb45-17" data-line-number="17"></a>
<a class="sourceLine" id="cb45-18" data-line-number="18"><span class="kw">head</span>(b.cls_m)</a>
<a class="sourceLine" id="cb45-19" data-line-number="19"><span class="kw">colnames</span>(b.cls_m)[<span class="kw">which</span>(<span class="kw">names</span>(b.cls_m) <span class="op">==</span><span class="st"> &quot;variable&quot;</span>)] &lt;-<span class="st"> &quot;Class&quot;</span></a>
<a class="sourceLine" id="cb45-20" data-line-number="20"><span class="kw">colnames</span>(b.cls_m)[<span class="kw">which</span>(<span class="kw">names</span>(b.cls_m) <span class="op">==</span><span class="st"> &quot;value&quot;</span>)] &lt;-<span class="st"> &quot;Counts&quot;</span></a>
<a class="sourceLine" id="cb45-21" data-line-number="21"><span class="kw">head</span>(b.cls_m) <span class="co">## relative abundance based on sum of counts by class!</span></a></code></pre></div>
<div id="taxonomic-summaries" class="section level3">
<h3><span class="header-section-number">4.4.1</span> Taxonomic Summaries</h3>
<p>Now that we have calculated the relativized counts by class according to our sample categories, let’s visualize it! Instead of a stacked barplot, we could visualize this in a different way - shout out to Dr. Mike Lee for sharing this technique in his amplicon <a href="https://astrobiomike.github.io/amplicon/dada2_workflow_ex">tutorial</a>!</p>
<p>Dr. Lee visualized the proportions of gene copies recovered in a way that he calls <strong>taxonomic summaries</strong>. These summaries allow us to view the relative abundance (or gene copy number, or any abundance measurement) of our microbes by having our x-axis be the taxa themselves rather than the sample IDs or the group labels. Personally I find these taxonomic summaries useful for comparing the relative abundance of specific taxa across multiple groups. To provide an example that’s easy to look at, we are going to view microbial classes by category that have a relative abundance of at least 1% or higher per sample.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1">cat_meta&lt;-<span class="kw">unique</span>(<span class="kw">data.frame</span>(<span class="st">&quot;Category&quot;</span>=metadata<span class="op">$</span>Category, <span class="st">&quot;Category_col&quot;</span>=metadata<span class="op">$</span>Category_col, <span class="st">&quot;SampleID&quot;</span>=metadata<span class="op">$</span>SampleID))</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">cls_cat_meta&lt;-<span class="kw">merge</span>(cat_meta,b.cls_m, <span class="dt">by=</span><span class="st">&quot;SampleID&quot;</span>)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3"><span class="kw">head</span>(cls_cat_meta)</a>
<a class="sourceLine" id="cb46-4" data-line-number="4"></a>
<a class="sourceLine" id="cb46-5" data-line-number="5"><span class="co"># Subset data to include only classes with relative abundance &gt; 1%</span></a>
<a class="sourceLine" id="cb46-6" data-line-number="6">cls_cat<span class="fl">.1</span>&lt;-<span class="kw">subset</span>(cls_cat_meta, cls_cat_meta<span class="op">$</span>Counts<span class="op">&gt;</span><span class="fl">0.01</span>)</a>
<a class="sourceLine" id="cb46-7" data-line-number="7"></a>
<a class="sourceLine" id="cb46-8" data-line-number="8">ts1&lt;-<span class="kw">ggplot</span>(cls_cat<span class="fl">.1</span>, <span class="kw">aes</span>(Class, Counts)) <span class="op">+</span></a>
<a class="sourceLine" id="cb46-9" data-line-number="9"><span class="st">  </span><span class="kw">geom_jitter</span>(<span class="kw">aes</span>(<span class="dt">color=</span><span class="kw">factor</span>(Category)), <span class="dt">size=</span><span class="dv">2</span>, <span class="dt">width=</span><span class="fl">0.15</span>, <span class="dt">height=</span><span class="dv">0</span>) <span class="op">+</span><span class="st"> </span><span class="kw">scale_color_manual</span>(<span class="dt">name =</span><span class="st">&quot;Sample Category&quot;</span>, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>),<span class="dt">values=</span><span class="kw">unique</span>(cls_cat_meta<span class="op">$</span>Category_col[<span class="kw">order</span>(cls_cat_meta<span class="op">$</span>Category)])) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>(<span class="dt">fill=</span><span class="ot">NA</span>, <span class="dt">outlier.color=</span><span class="ot">NA</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>,<span class="dt">angle=</span><span class="dv">90</span>),<span class="dt">legend.title.align=</span><span class="fl">0.5</span>, <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">15</span>),<span class="dt">plot.subtitle =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">12</span>)) <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="st">&quot;Microbial Class&quot;</span>, <span class="dt">y=</span><span class="st">&quot;Relative Abundance&quot;</span>, <span class="dt">title=</span><span class="st">&quot;Bacteria/Archaea &amp; Sample Category&quot;</span>, <span class="dt">subtitle=</span><span class="st">&quot;Only Including Taxa with Relative Abudance &gt; 1%&quot;</span>)</a>
<a class="sourceLine" id="cb46-10" data-line-number="10"></a>
<a class="sourceLine" id="cb46-11" data-line-number="11"><span class="kw">ggsave</span>(ts1,<span class="dt">filename =</span> <span class="st">&quot;16S_Class_1percent_RA_category.png&quot;</span>, <span class="dt">width=</span><span class="dv">12</span>, <span class="dt">height=</span><span class="dv">10</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_Class_1percent_RA_category.png" />
</center>
<div align="center">
Figure 14: Taxonomic Summary of Bacterial Relative Abundance (&gt; 1%) by Class Per Sample. Colored by Sample Category.
</div>
<p></br></p>
<p>This taxonomic summary tells us that Old Growth samples have a higher relative abundance (&gt;20-40%) of the Acidimicrobiia class compared to samples belonging to the other categories. Gammaproteobacteria appears to be the most abundant class in Clear Cut Soil samples, with some samples having a relative abundance of this taxa that is greater than 20%. Interestingly, these samples from the Clear Cut Soil category are the only samples contain Bacilli, though this could be due to our 1% relative abundancer threshold for this figure.</p>
</div>
<div id="relative-abundance-by-category" class="section level3">
<h3><span class="header-section-number">4.4.2</span> Relative Abundance by Category</h3>
<p>Maybe it would be helpful to know the relative abundance of taxa by the categories themselves rather than the relative abundance by sample. We can easily calculate this and visualize a stacked barplot to compare sample categories.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">head</span>(all_bac)</a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="co"># by class + elevation</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">bac.cls.cat &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">dcast</span>(all_bac,Category<span class="op">~</span>Class, <span class="dt">value.var=</span><span class="st">&quot;Counts&quot;</span>, <span class="dt">fun.aggregate=</span>sum)) <span class="co">### </span></a>
<a class="sourceLine" id="cb47-4" data-line-number="4"><span class="kw">head</span>(bac.cls.cat) <span class="co"># counts by class + elevation</span></a>
<a class="sourceLine" id="cb47-5" data-line-number="5"><span class="kw">rownames</span>(bac.cls.cat)&lt;-bac.cls.cat<span class="op">$</span>Category</a>
<a class="sourceLine" id="cb47-6" data-line-number="6"></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">b.RA_cls.cat&lt;-<span class="kw">data.frame</span>(<span class="kw">decostand</span>(bac.cls.cat[,<span class="op">-</span><span class="dv">1</span>], <span class="dt">method=</span><span class="st">&quot;total&quot;</span>, <span class="dt">MARGIN=</span><span class="dv">1</span>, <span class="dt">na.rm=</span><span class="ot">TRUE</span>))  </a>
<a class="sourceLine" id="cb47-8" data-line-number="8"><span class="co"># relative abundance of taxa data where everything is divided by margin total (default MARGIN = 1 = rows) -- rows = samples</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9"><span class="kw">rowSums</span>(b.RA_cls.cat) <span class="co"># sanity check</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10">b.RA_cls.cat<span class="op">$</span>Category&lt;-<span class="kw">rownames</span>(b.RA_cls.cat)</a>
<a class="sourceLine" id="cb47-11" data-line-number="11"><span class="kw">head</span>(b.RA_cls.cat)</a>
<a class="sourceLine" id="cb47-12" data-line-number="12"></a>
<a class="sourceLine" id="cb47-13" data-line-number="13"><span class="co">#melt down relativized data to merge with metadata</span></a>
<a class="sourceLine" id="cb47-14" data-line-number="14">b.cls.cat_m&lt;-<span class="kw">melt</span>(b.RA_cls.cat, <span class="dt">by=</span><span class="st">&quot;Category&quot;</span>)</a>
<a class="sourceLine" id="cb47-15" data-line-number="15"></a>
<a class="sourceLine" id="cb47-16" data-line-number="16"><span class="kw">head</span>(b.cls.cat_m)</a>
<a class="sourceLine" id="cb47-17" data-line-number="17"><span class="kw">colnames</span>(b.cls.cat_m)[<span class="kw">which</span>(<span class="kw">names</span>(b.cls.cat_m) <span class="op">==</span><span class="st"> &quot;variable&quot;</span>)] &lt;-<span class="st"> &quot;Class&quot;</span></a>
<a class="sourceLine" id="cb47-18" data-line-number="18"><span class="kw">colnames</span>(b.cls.cat_m)[<span class="kw">which</span>(<span class="kw">names</span>(b.cls.cat_m) <span class="op">==</span><span class="st"> &quot;value&quot;</span>)] &lt;-<span class="st"> &quot;Counts&quot;</span></a>
<a class="sourceLine" id="cb47-19" data-line-number="19"><span class="kw">head</span>(b.cls.cat_m) <span class="co">## relative abundance based on sum of counts by class!</span></a>
<a class="sourceLine" id="cb47-20" data-line-number="20"></a>
<a class="sourceLine" id="cb47-21" data-line-number="21"><span class="co"># Subset data to include only classes with relative abundance &gt; 1%</span></a>
<a class="sourceLine" id="cb47-22" data-line-number="22">b.cls.cat<span class="fl">.1</span>&lt;-<span class="kw">subset</span>(b.cls.cat_m, b.cls.cat_m<span class="op">$</span>Counts<span class="op">&gt;</span><span class="fl">0.01</span>)</a>
<a class="sourceLine" id="cb47-23" data-line-number="23"></a>
<a class="sourceLine" id="cb47-24" data-line-number="24">c1&lt;-<span class="kw">ggplot</span>(b.cls.cat<span class="fl">.1</span>, <span class="kw">aes</span>(<span class="dt">x=</span>Category, <span class="dt">y=</span>Counts, <span class="dt">fill=</span>Class))<span class="op">+</span><span class="kw">geom_bar</span>(<span class="dt">stat=</span><span class="st">&quot;identity&quot;</span>,<span class="dt">colour=</span><span class="st">&quot;black&quot;</span>)<span class="op">+</span><span class="kw">scale_x_discrete</span>(<span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;ClearCutSoil&quot;</span>=<span class="st">&quot;Clear Cut Soil&quot;</span>, <span class="st">&quot;Gopher&quot;</span>=<span class="st">&quot;Gopher&quot;</span>, <span class="st">&quot;NoGopher&quot;</span>=<span class="st">&quot;No Gopher&quot;</span>, <span class="st">&quot;OldGrowth&quot;</span>=<span class="st">&quot;Old Growth&quot;</span>))<span class="op">+</span><span class="kw">theme_classic</span>()<span class="op">+</span></a>
<a class="sourceLine" id="cb47-25" data-line-number="25"><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Microbial Class Relative Abundance&quot;</span>, <span class="dt">x=</span><span class="st">&quot;Sample Category&quot;</span>, <span class="dt">y=</span><span class="st">&quot;Relative Abundance&quot;</span>, <span class="dt">fill=</span><span class="st">&quot;Class&quot;</span>, <span class="dt">subtitle=</span><span class="st">&quot;Only Including Taxa with Relative Abudance &gt; 1%&quot;</span>)<span class="op">+</span></a>
<a class="sourceLine" id="cb47-26" data-line-number="26"><span class="st">  </span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>),<span class="dt">legend.title.align=</span><span class="fl">0.5</span>, <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">plot.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">15</span>),<span class="dt">plot.subtitle =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>))</a>
<a class="sourceLine" id="cb47-27" data-line-number="27"></a>
<a class="sourceLine" id="cb47-28" data-line-number="28"><span class="kw">ggsave</span>(c1,<span class="dt">filename =</span> <span class="st">&quot;16S_Class_1percent_RA_byCategory.png&quot;</span>, <span class="dt">width=</span><span class="dv">12</span>, <span class="dt">height=</span><span class="dv">10</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_Class_1percent_RA_byCategory.png" />
</center>
<div align="center">
Figure 15: Relative Abundance (&gt; 1%) of Bacterial Classes by Sample Category
</div>
<p></br></p>
<p>Instead of viewing the relative abundance of classes by sample as we did in the taxonomic summary, we are now looking at the relativea abundance of taxa within the categories themselves. For example, we can tell that out of all of the categories, samples within the Old Growth category have the highest relative abundance of the Acidobacteriae class. Gammaproteobacteria appears to be the most abundant in the Clear Cut Soil category, whereas Bacteroidia is the most abundant class in the No Gopher category. Though our taxonomic summaries helped us to see these trends, these stacked bar plots offer some more insight to category-specific trends.</p>
</div>
</div>
<div id="environmental-drivers" class="section level2">
<h2><span class="header-section-number">4.5</span> Environmental Drivers</h2>
<p>The last step in this workflow is to determine how our microbial community composition corresponds to environmental variables. To do this, we can run either a <strong>Canonical Correspondence Analysis</strong> (aka CCA) or a <strong>Redundancy Analysis</strong> (aka RDA). These are ordination techniques that allow us to correlate our composition data with our environmental variables to explain the variance in our microbial community structures. CCAs and RDAs utilize eigenanalysis, which is quite out of the scope of this tutorial. I highly recommend watching this <a href="https://www.youtube.com/watch?v=PFDu9oVAE-g">YouTube video</a> detailing what <em>eigenvectors</em> and <em>eigenvalues</em> are and why they’re essential in linear algebra and statistics.</p>
<p>A CCA considers how community composition relates to a set of defined constraints, which would be your environmental variables of interests. CCAs assume that your composition data will have a <strong>unimodal</strong> (aka have one maximum value) relationship with the environmental variables. Typically for a CCA you already know exactly what environmental variables you will be considering. It’s important to note that if your model (how your environmental variables influence your community composition) is not statistically significant, then your results are not meaningful enough to discuss.</p>
<p>A RDA can tell us whether our environmental variables explain the variation we observe in our microbial communities, or whether or not their impact on community structure is redundant (i.e., the variation is explained by something else). RDAs assume that your composition data will have a <strong>linear</strong> relationship with your environmental data. Variance described by our environmental response variables is known as <em>constrained variance</em>, whereas variance described by unknown variables (or variables excluded from our response variables) is called <em>unconstrained variance</em>.</p>
<p>So at this point you’re probably asking yourself “how do I know if my data has a unimodal or linear relationship with my environmental variables?”, and that’s a great question! We can use a <strong>Detrended Correspondence Analysis</strong> (aka DCA) to help us decide whether we should use a CCA or an RDA for our composition data. If the length of our first DCA axis is <em>longer than 4</em>, that indicates that our data is heterogeneous and requires unimodal methods like a CCA. If the length of our first DCA axis is <em>less than 3</em>, the data is considered homogeneous and thus requires linear methods like an RDA. If your first axis length is between 3 and 4, then it’s up to you to choose whether to use an RDA or a CCA.</p>
<p>For more information on how CCAs and RDAs are calculated and their applications, please view this helpful <a href="http://dmcglinn.github.io/quant_methods/lessons/multivariate_models.html">tutorial</a> for a deep look into different Euclidean-based ordinations. I also recommend watching Dr. Ralf Shaefer’s <a href="https://www.youtube.com/watch?v=AjU6s7-EBGY&amp;t=1s">YouTube video on RDAs</a> as well as this helpful <a href="https://youtu.be/tVnnG7mFeqA">YouTube video</a> that walks you through different ordination techniques using the <code>vegan</code> package in R.</p>
<div id="prep-step-1-detrended-correspondence-analysis-dca" class="section level3">
<h3><span class="header-section-number">4.5.1</span> Prep Step 1: Detrended Correspondence Analysis (DCA)</h3>
<p>Let’s first run a DCA to determine the length of our first axis and decide which ordination technique to use. For this we are going to use our <strong>CLR-transformed ASV table</strong> as our site x species matrix. The <code>decorana()</code> function from vegan performs the DCA, which requires that the row sums are greater than zero. Because clr transformed data can have negative values, I’ve decided to add a pseudocount of 1 to the matrix to fulfill the requirements of the <code>decorana()</code> function.</p>
<p><strong>Note: The chemical data I will be using for this portion of the workflow is not real data from this project. These data come from a different project and are being used just for this example.</strong></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co">## remember, CCA assumes that our species have a unimodal relationship with our variables.</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2"><span class="co">### unimodal = one maximum, think upsidedown bellcurve or something</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3"><span class="co">## RDA assumes a linear relationship</span></a>
<a class="sourceLine" id="cb48-4" data-line-number="4"><span class="co">## check the assumption</span></a>
<a class="sourceLine" id="cb48-5" data-line-number="5">chem_data&lt;-<span class="kw">subset</span>(metadata, <span class="dt">select=</span><span class="kw">c</span>(Cu, Mn, P))</a>
<a class="sourceLine" id="cb48-6" data-line-number="6"><span class="kw">pairs</span>(<span class="kw">c</span>(b.clr[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],chem_data))</a>
<a class="sourceLine" id="cb48-7" data-line-number="7"></a>
<a class="sourceLine" id="cb48-8" data-line-number="8"><span class="co">## The length of first DCA axis:</span></a>
<a class="sourceLine" id="cb48-9" data-line-number="9"><span class="co">## &gt; 4 indicates heterogeneous dataset on which unimodal methods should be used (CCA), </span></a>
<a class="sourceLine" id="cb48-10" data-line-number="10"><span class="co">##  &lt; 3 indicates homogeneous dataset for which linear methods are suitable (RDA) </span></a>
<a class="sourceLine" id="cb48-11" data-line-number="11"><span class="co">## between 3 and 4 both linear and unimodal methods are OK.</span></a>
<a class="sourceLine" id="cb48-12" data-line-number="12"></a>
<a class="sourceLine" id="cb48-13" data-line-number="13"><span class="kw">head</span>(b.clr)</a>
<a class="sourceLine" id="cb48-14" data-line-number="14"></a>
<a class="sourceLine" id="cb48-15" data-line-number="15"><span class="co"># add pseudocount so row sums are &gt; 0</span></a>
<a class="sourceLine" id="cb48-16" data-line-number="16">b.clr.pseudo&lt;-b.clr<span class="op">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb48-17" data-line-number="17">b.dca =<span class="st"> </span><span class="kw">decorana</span>(b.clr.pseudo)</a>
<a class="sourceLine" id="cb48-18" data-line-number="18"><span class="co">#plot(b.dca) # may take too long to load</span></a>
<a class="sourceLine" id="cb48-19" data-line-number="19"><span class="kw">summary</span>(b.dca) <span class="co">#DCA1 axis length = 1.7990; use RDA</span></a></code></pre></div>
<p>Our first DCA axis has a length of 1.7990, which suggests that we should run an RDA with our data.</p>
</div>
<div id="prep-step-2-scale-environmtanl-data-subset" class="section level3">
<h3><span class="header-section-number">4.5.2</span> Prep Step 2: Scale Environmtanl Data &amp; Subset</h3>
<p>We first want to scale our environmental data so that they are comparable to each other, despite their initial measurements being vastly different (i.e., your mg of Cu and mg of P are not immediatley comparable). At this point, we could jump into doing an RDA…but it may be more informative if we look at the environmental drivers of each category or site one by one rather than considering the drivers across sites.</p>
<p>To subset our data, we will use the <code>lapply()</code> function: if <code>metdata$Category</code> is the same as (<code>==</code>) the element(s) in <code>site_list</code>, subset the metadata data frame by the <code>site_list</code> element into a new list called <code>site_subsets</code>. After this step, we will have a list where each element in the list (<code>site_subsets[[i]]</code>) will contain all of the metadata for each respective Category.</p>
<p>I have also provided examples on how to subset lists for practice - indexing in R can be tricky in the beginning, and personally I need to review it often.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co"># create metadata df that will have scaled chemical data</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">meta_scaled&lt;-metadata</a>
<a class="sourceLine" id="cb49-3" data-line-number="3"><span class="kw">head</span>(meta_scaled)</a>
<a class="sourceLine" id="cb49-4" data-line-number="4">meta_scaled[,<span class="dv">17</span><span class="op">:</span><span class="dv">19</span>]&lt;-<span class="kw">as.data.frame</span>(<span class="kw">scale</span>(meta_scaled[,<span class="dv">17</span><span class="op">:</span><span class="dv">19</span>], <span class="dt">center=</span><span class="ot">TRUE</span>, <span class="dt">scale=</span><span class="ot">TRUE</span>)) <span class="co">#not centering before scaling</span></a>
<a class="sourceLine" id="cb49-5" data-line-number="5"><span class="kw">head</span>(meta_scaled)</a>
<a class="sourceLine" id="cb49-6" data-line-number="6"></a>
<a class="sourceLine" id="cb49-7" data-line-number="7"><span class="kw">unique</span>(meta_scaled<span class="op">$</span>Category)</a>
<a class="sourceLine" id="cb49-8" data-line-number="8"></a>
<a class="sourceLine" id="cb49-9" data-line-number="9">site_list&lt;-<span class="kw">unique</span>(meta_scaled<span class="op">$</span>Category) <span class="co">#define an array of string values</span></a>
<a class="sourceLine" id="cb49-10" data-line-number="10"></a>
<a class="sourceLine" id="cb49-11" data-line-number="11"><span class="co"># go through metadata &amp; create a list of data frames </span></a>
<a class="sourceLine" id="cb49-12" data-line-number="12"><span class="co">## when metadata$Category == element in site_list (aka x in this case), subset metadata by said element into elements of a list</span></a>
<a class="sourceLine" id="cb49-13" data-line-number="13">site_subsets&lt;-<span class="kw">lapply</span>(site_list, <span class="cf">function</span>(x) {<span class="kw">subset</span>(meta_scaled, Category<span class="op">==</span>x)})</a>
<a class="sourceLine" id="cb49-14" data-line-number="14"><span class="co"># here the function(x) is using site_list aka x to subset metadata, when $Category column == site_list</span></a>
<a class="sourceLine" id="cb49-15" data-line-number="15"></a>
<a class="sourceLine" id="cb49-16" data-line-number="16">site_subsets <span class="co"># sanity check1 (should see all elements in list)</span></a>
<a class="sourceLine" id="cb49-17" data-line-number="17">site_subsets[[<span class="dv">1</span>]] <span class="co"># sanity check2 (see 1st element in list)</span></a>
<a class="sourceLine" id="cb49-18" data-line-number="18"><span class="co">#rename the list elements</span></a>
<a class="sourceLine" id="cb49-19" data-line-number="19"></a>
<a class="sourceLine" id="cb49-20" data-line-number="20"><span class="co"># name each element in list</span></a>
<a class="sourceLine" id="cb49-21" data-line-number="21"><span class="kw">names</span>(site_subsets)&lt;-site_list <span class="co"># * only do this if the order of names in site_list match order of the elements in site_subsets!</span></a>
<a class="sourceLine" id="cb49-22" data-line-number="22">site_subsets<span class="op">$</span>ClearCutSoil <span class="co"># sanity check3 - should be able to pull dataframes by names rather than index now</span></a>
<a class="sourceLine" id="cb49-23" data-line-number="23"></a>
<a class="sourceLine" id="cb49-24" data-line-number="24"><span class="co"># example of subsetting</span></a>
<a class="sourceLine" id="cb49-25" data-line-number="25">site_subsets[[<span class="dv">2</span>]][<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb49-26" data-line-number="26">site_subsets<span class="op">$</span>Gopher[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>] <span class="co"># should produce same ouptut as line above</span></a>
<a class="sourceLine" id="cb49-27" data-line-number="27"></a>
<a class="sourceLine" id="cb49-28" data-line-number="28">site_subsets[[<span class="dv">2</span>]][<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>] <span class="co"># another example</span></a>
<a class="sourceLine" id="cb49-29" data-line-number="29"></a>
<a class="sourceLine" id="cb49-30" data-line-number="30"><span class="co"># ^ subsetting to [[second dataframe]], [[row #, column #]]</span></a>
<a class="sourceLine" id="cb49-31" data-line-number="31">site_subsets[[<span class="dv">2</span>]][[<span class="dv">1</span>,<span class="dv">2</span>]] <span class="co"># [[second dataframe]], [[row 1, column 2]]</span></a></code></pre></div>
<p>The next step is to take each element in our list and make a new data frame, so that we have data frames of the metadata separated by Category. I have written a custom function called <code>df_specific.subset</code> to do this, but if you know an easier way of doing this, feel free to use that instead!</p>
<p>At the end of this step, we should have data frames of each category containing all of their respective metadata.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="co"># set up the function and run this to store it in our Global environment</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2">df_specific.subset&lt;-<span class="cf">function</span>(var_vec,var_subsets){ </a>
<a class="sourceLine" id="cb50-3" data-line-number="3">  <span class="co"># var_vec = vector of variable elements from specific categorical variable; </span></a>
<a class="sourceLine" id="cb50-4" data-line-number="4">  <span class="co">## e.g. vector of names from Site categorical variable (metadata sites)</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5">  <span class="co"># var_subsets = list of dataframes subsetted by column$element from original dataframe;</span></a>
<a class="sourceLine" id="cb50-6" data-line-number="6">  <span class="co">## e.g. list of dataframes (each df = element of list) subsetted from metadata using vector of metadata$Site names</span></a>
<a class="sourceLine" id="cb50-7" data-line-number="7">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(var_vec)){</a>
<a class="sourceLine" id="cb50-8" data-line-number="8">    <span class="co"># print(var_vec[i]) -- var_vec[i] = each element in var_vec</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9">    <span class="co"># print(var_subsets[[i]]) -- var_subsets[[i]] = each sub</span></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">    df&lt;-<span class="kw">paste</span>(var_vec[i])</a>
<a class="sourceLine" id="cb50-11" data-line-number="11">    <span class="co">#print(df)</span></a>
<a class="sourceLine" id="cb50-12" data-line-number="12">    <span class="kw">assign</span>(df, var_subsets[[i]], <span class="dt">envir =</span> .GlobalEnv)</a>
<a class="sourceLine" id="cb50-13" data-line-number="13">    <span class="kw">print</span>(<span class="kw">paste</span>(<span class="st">&quot;Dataframe&quot;</span>, var_vec[i] ,<span class="st">&quot;done&quot;</span>))</a>
<a class="sourceLine" id="cb50-14" data-line-number="14">    </a>
<a class="sourceLine" id="cb50-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb50-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb50-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb50-18" data-line-number="18"></a>
<a class="sourceLine" id="cb50-19" data-line-number="19"><span class="co"># run the function</span></a>
<a class="sourceLine" id="cb50-20" data-line-number="20"><span class="kw">df_specific.subset</span>(site_list, site_subsets) <span class="co"># used scaled metadata quantitative values</span></a>
<a class="sourceLine" id="cb50-21" data-line-number="21"></a>
<a class="sourceLine" id="cb50-22" data-line-number="22"><span class="kw">head</span>(ClearCutSoil) <span class="co"># sanity check</span></a>
<a class="sourceLine" id="cb50-23" data-line-number="23">ClearCutSoil[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,<span class="dv">17</span><span class="op">:</span><span class="dv">19</span>] <span class="co"># double check that our new Category data frames still have scaled chemical data</span></a></code></pre></div>
<p>Now that we have data frames containing all of the metadata by category, we need to match these data frames up with our composition data (our transformed ASV table). We are going to use another custom function I wrote called <code>match_dat</code> to do this. First we have to run the function to make sure it’s in our Global Environment, and then we can use it. To save time, I am only going to use one of our category data frames to match up with our transformed composition data.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="co"># matching data with user defined function</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">match_dat&lt;-<span class="cf">function</span>(compdata, subset_metadata){</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">  subset_comp_data =<span class="st"> </span>pullrow&lt;-(<span class="kw">is.element</span>(<span class="kw">row.names</span>(compdata), <span class="kw">row.names</span>(subset_metadata)))</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">  <span class="co">### * comp data and metadata need to have row names - rownames should be Sample IDs</span></a>
<a class="sourceLine" id="cb51-5" data-line-number="5">  subset_comp_data=compdata[pullrow,]</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">  <span class="kw">return</span>(subset_comp_data)</a>
<a class="sourceLine" id="cb51-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb51-8" data-line-number="8"></a>
<a class="sourceLine" id="cb51-9" data-line-number="9"><span class="co"># check that our data frames are ready for this function, aka that they both have the same rownames</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10"><span class="co">## row #s do not have to be the same, but their row names should be in the same format and be able to match up</span></a>
<a class="sourceLine" id="cb51-11" data-line-number="11"><span class="kw">rownames</span>(b.clr)</a>
<a class="sourceLine" id="cb51-12" data-line-number="12"><span class="kw">rownames</span>(ClearCutSoil)</a>
<a class="sourceLine" id="cb51-13" data-line-number="13"></a>
<a class="sourceLine" id="cb51-14" data-line-number="14"><span class="co"># run the function</span></a>
<a class="sourceLine" id="cb51-15" data-line-number="15">b.clr_C.C.S&lt;-<span class="kw">match_dat</span>(b.clr,ClearCutSoil)</a>
<a class="sourceLine" id="cb51-16" data-line-number="16"></a>
<a class="sourceLine" id="cb51-17" data-line-number="17"><span class="co"># did the function work the way we wanted it to? let&#39;s check!</span></a>
<a class="sourceLine" id="cb51-18" data-line-number="18"><span class="kw">head</span>(b.clr_C.C.S)</a>
<a class="sourceLine" id="cb51-19" data-line-number="19"><span class="kw">rownames</span>(ClearCutSoil) <span class="op">%in%</span><span class="st"> </span><span class="kw">rownames</span>(b.clr_C.C.S) <span class="co"># hopefully all of the rownames match, aka will get output of TRUE</span></a></code></pre></div>
</div>
</div>
<div id="redundancy-analysis-rda" class="section level2">
<h2><span class="header-section-number">4.6</span> Redundancy Analysis (RDA)</h2>
<p>Now that we have the metadata and the corresponding transformed ASV counts for the samples in the Clear Cut Soil category, we can run an <strong>RDA</strong> with the <code>rda()</code> function from the <code>vegan</code> package to see if our variables of interest drive our microbial community composition.</p>
<p>If your DCA 1 axis was longer than 3 and you needed to run a <strong>CCA</strong>, all of these steps would be the same <em>except</em> that instead of using the <code>rda()</code> function by <code>vegan</code>, you would use the <code>cca()</code> function. Similar to the <code>decorana</code> function, you may need to add a small pseudocount to your transformed feature table before you run the <code>cca()</code> function.</p>
<p>To view the results of our rda, we will use the <code>summary()</code> function, and we can check the amount of variation explained by the model (i.e., R<sup>2</sup>) using the <code>RsquareAdj()</code> function. It’s wise to use the adjusted R<sup>2</sup> value because the more variables included in the model, the more inflated your R<sup>2</sup> value will be. We can also check out the individual terms of the model and their respective impact via an <code>anova()</code>. Lastly, we can see exactly which variables are the drivers of variation in our model using the <code>ordistep()</code> function. Based on the results of this last step, we can adjust our model and re-run the RDA.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1">rda.ccs&lt;-<span class="kw">rda</span>(b.clr_C.C.S <span class="op">~</span><span class="st"> </span>Cu <span class="op">+</span><span class="st"> </span>Mn <span class="op">+</span><span class="st"> </span>P, <span class="dt">data=</span>ClearCutSoil)</a>
<a class="sourceLine" id="cb52-2" data-line-number="2"></a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="co"># plot RDA</span></a>
<a class="sourceLine" id="cb52-4" data-line-number="4"><span class="co">#plot(rda.ccs) # depending on how many species you have, this step may take a while</span></a>
<a class="sourceLine" id="cb52-5" data-line-number="5"><span class="kw">plot</span>(rda.ccs, <span class="dt">scaling =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb52-6" data-line-number="6"><span class="co">## scaling = 1 -&gt; emphasizes relationships among sites</span></a>
<a class="sourceLine" id="cb52-7" data-line-number="7"><span class="kw">plot</span>(rda.ccs, <span class="dt">scaling =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb52-8" data-line-number="8"><span class="co">## scaling = 2 -&gt; emphasizes relationships among species</span></a>
<a class="sourceLine" id="cb52-9" data-line-number="9"></a>
<a class="sourceLine" id="cb52-10" data-line-number="10"><span class="co"># check summary of RDA</span></a>
<a class="sourceLine" id="cb52-11" data-line-number="11"><span class="kw">summary</span>(rda.ccs)</a>
<a class="sourceLine" id="cb52-12" data-line-number="12"></a>
<a class="sourceLine" id="cb52-13" data-line-number="13"><span class="co"># how much variation does our model explain?</span></a>
<a class="sourceLine" id="cb52-14" data-line-number="14"><span class="co">## reminder: R^2 = % of variation in dependent variable explained by model</span></a>
<a class="sourceLine" id="cb52-15" data-line-number="15"><span class="kw">RsquareAdj</span>(rda.ccs) <span class="co"># 2.94%</span></a>
<a class="sourceLine" id="cb52-16" data-line-number="16"><span class="co">## ^^ use this b/c chance correlations can inflate R^2</span></a>
<a class="sourceLine" id="cb52-17" data-line-number="17"></a>
<a class="sourceLine" id="cb52-18" data-line-number="18"><span class="co">## we can then test for significance of the model by permutation</span></a>
<a class="sourceLine" id="cb52-19" data-line-number="19"><span class="co">## if it is not significant, it doesn&#39;t matter how much of the variation is explained</span></a>
<a class="sourceLine" id="cb52-20" data-line-number="20"><span class="kw">anova</span>(rda.ccs, <span class="dt">permutations =</span> <span class="kw">how</span>(<span class="dt">nperm=</span><span class="dv">999</span>))</a>
<a class="sourceLine" id="cb52-21" data-line-number="21"></a>
<a class="sourceLine" id="cb52-22" data-line-number="22"><span class="co">## we can also do a permutation test by axis </span></a>
<a class="sourceLine" id="cb52-23" data-line-number="23"><span class="kw">anova</span>(rda.ccs, <span class="dt">by =</span> <span class="st">&quot;axis&quot;</span>, <span class="dt">permutations =</span> <span class="kw">how</span>(<span class="dt">nperm=</span><span class="dv">999</span>)) <span class="co">### by RDA axis</span></a>
<a class="sourceLine" id="cb52-24" data-line-number="24"><span class="co">## or by terms</span></a>
<a class="sourceLine" id="cb52-25" data-line-number="25"><span class="kw">anova</span>(rda.ccs, <span class="dt">by =</span> <span class="st">&quot;terms&quot;</span>, <span class="dt">permutations =</span> <span class="kw">how</span>(<span class="dt">nperm=</span><span class="dv">999</span>)) <span class="co">### by variables</span></a>
<a class="sourceLine" id="cb52-26" data-line-number="26"><span class="co">## this will help us interpret our RDA and we can see some variable are not significant</span></a>
<a class="sourceLine" id="cb52-27" data-line-number="27"></a>
<a class="sourceLine" id="cb52-28" data-line-number="28"><span class="co">## we can use model selection instead of picking variables we think are important</span></a>
<a class="sourceLine" id="cb52-29" data-line-number="29">rda.ccs.a =<span class="st"> </span><span class="kw">ordistep</span>(<span class="kw">rda</span>(b.clr_C.C.S <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> ClearCutSoil[,<span class="dv">17</span><span class="op">:</span><span class="dv">19</span>]),</a>
<a class="sourceLine" id="cb52-30" data-line-number="30">                  <span class="dt">scope=</span><span class="kw">formula</span>(rda.ccs),</a>
<a class="sourceLine" id="cb52-31" data-line-number="31">                  <span class="dt">direction =</span> <span class="st">&quot;forward&quot;</span>,</a>
<a class="sourceLine" id="cb52-32" data-line-number="32">                  <span class="dt">permutations =</span> <span class="kw">how</span>(<span class="dt">nperm=</span><span class="dv">999</span>))</a></code></pre></div>
<p>Because our model was not significant, normally we would stop here and not visualize this RDA. However, the point of this workflow is to provide you with the code to run and visualize these analyses yourselves, so I am going to show you how I would visualize this RDA.</p>
<p>The <code>ggvegan</code> <a href="https://github.com/gavinsimpson/ggvegan">package</a> is a useful package that takes advantage of some of the difficulties of <code>ggplot2</code> when it comes to plotting ordinations. This package has a function called <code>autoplot</code> which helps us easily plot an RDA.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="kw">png</span>(<span class="st">&#39;autoplot_rda_example.png&#39;</span>,<span class="dt">width =</span> <span class="dv">700</span>, <span class="dt">height =</span> <span class="dv">600</span>, <span class="dt">res=</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="kw">autoplot</span>(rda.ccs, <span class="dt">arrows =</span> <span class="ot">TRUE</span>,<span class="dt">data =</span> rda.ccs ,<span class="dt">layers=</span><span class="kw">c</span>(<span class="st">&quot;biplot&quot;</span>,<span class="st">&quot;sites&quot;</span>),<span class="dt">label =</span> <span class="ot">FALSE</span>, <span class="dt">label.size =</span> <span class="dv">3</span>, <span class="dt">shape =</span> <span class="ot">FALSE</span>, <span class="dt">loadings =</span> <span class="ot">TRUE</span>, <span class="dt">loadings.colour =</span> <span class="st">&#39;blue&#39;</span>, <span class="dt">loadings.label =</span> <span class="ot">TRUE</span>, <span class="dt">loadings.label.size =</span> <span class="dv">3</span>, <span class="dt">scale=</span> <span class="dv">0</span>)<span class="op">+</span><span class="kw">theme_classic</span>()</a>
<a class="sourceLine" id="cb53-3" data-line-number="3"><span class="kw">dev.off</span>()</a></code></pre></div>
<center>
<img src="amplicon_workflow/autoplot_rda_example.png" />
</center>
<div align="center">
Figure 16: Redundancy Analysis Autoplot for the Clear Cut Soil category by <code>ggvegan</code>
</div>
<p></br></p>
<p>We can also extract data from the <code>summary(rda)</code> object and use this information to create our own RDA plot with <code>ggplot2</code>. I am going to show you two versions of the plot: one version that has not been altered in any way (Figure 17a), and an RDA where the axes pointing to our environmental variables have been amplified to match the autoplot (Figure 17b).</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1">rda.sum&lt;-<span class="kw">summary</span>(rda.ccs)</a>
<a class="sourceLine" id="cb54-2" data-line-number="2">rda.sum<span class="op">$</span>sites[,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</a>
<a class="sourceLine" id="cb54-3" data-line-number="3"></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"><span class="co"># create data frame w/ RDA axes for sites</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5">rda.axes&lt;-<span class="kw">data.frame</span>(<span class="dt">RDA1=</span>rda.sum<span class="op">$</span>sites[,<span class="dv">1</span>], <span class="dt">RDA2=</span>rda.sum<span class="op">$</span>sites[,<span class="dv">2</span>], <span class="dt">SampleID=</span><span class="kw">rownames</span>(rda.sum<span class="op">$</span>sites))</a>
<a class="sourceLine" id="cb54-6" data-line-number="6"></a>
<a class="sourceLine" id="cb54-7" data-line-number="7"><span class="co"># create data frame w/ RDA axes for variables</span></a>
<a class="sourceLine" id="cb54-8" data-line-number="8">arrows&lt;-<span class="kw">data.frame</span>(<span class="dt">RDA1=</span>rda.sum<span class="op">$</span>biplot[,<span class="dv">1</span>], <span class="dt">RDA2=</span>rda.sum<span class="op">$</span>biplot[,<span class="dv">2</span>], <span class="dt">Label=</span><span class="kw">rownames</span>(rda.sum<span class="op">$</span>biplot))</a>
<a class="sourceLine" id="cb54-9" data-line-number="9"></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">rda.plot1&lt;-<span class="kw">ggplot</span>(rda.axes, <span class="kw">aes</span>(<span class="dt">x =</span> RDA1, <span class="dt">y =</span> RDA2)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb54-11" data-line-number="11"><span class="st">  </span><span class="kw">geom_segment</span>(<span class="dt">data =</span> arrows,<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">0</span>, <span class="dt">y =</span> <span class="dv">0</span>, <span class="dt">xend =</span> RDA1, <span class="dt">yend =</span> RDA2),<span class="dt">lineend =</span> <span class="st">&quot;round&quot;</span>, <span class="co"># See available arrow types in example above</span></a>
<a class="sourceLine" id="cb54-12" data-line-number="12">               <span class="dt">linejoin =</span> <span class="st">&quot;round&quot;</span>,</a>
<a class="sourceLine" id="cb54-13" data-line-number="13">               <span class="dt">size =</span> <span class="fl">0.5</span>, </a>
<a class="sourceLine" id="cb54-14" data-line-number="14">               <span class="dt">arrow =</span> <span class="kw">arrow</span>(<span class="dt">length =</span> <span class="kw">unit</span>(<span class="fl">0.15</span>, <span class="st">&quot;inches&quot;</span>)),</a>
<a class="sourceLine" id="cb54-15" data-line-number="15">               <span class="dt">colour =</span> <span class="st">&quot;#7400b8&quot;</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb54-16" data-line-number="16"><span class="st">  </span><span class="kw">geom_label</span>(<span class="dt">data =</span> arrows,<span class="kw">aes</span>(<span class="dt">label =</span> Label, <span class="dt">x =</span> RDA1, <span class="dt">y =</span> RDA2, <span class="dt">fontface=</span><span class="st">&quot;bold&quot;</span>))<span class="op">+</span></a>
<a class="sourceLine" id="cb54-17" data-line-number="17"><span class="st">  </span><span class="kw">coord_fixed</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb54-18" data-line-number="18"><span class="st">  </span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb54-19" data-line-number="19"></a>
<a class="sourceLine" id="cb54-20" data-line-number="20"><span class="kw">ggsave</span>(rda.plot1,<span class="dt">filename =</span> <span class="st">&quot;16S_RDA_example1.png&quot;</span>, <span class="dt">width=</span><span class="dv">15</span>, <span class="dt">height=</span><span class="dv">12</span>, <span class="dt">dpi=</span><span class="dv">600</span>) =</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_RDA_example1.png" />
</center>
<div align="center">
Figure 17a: Redundancy Analysis of Clear Cut Soil samples w/ <code>ggplot2</code> Example 1
</div>
<p></br></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1">rda.plot2&lt;-<span class="kw">ggplot</span>(rda.axes, <span class="kw">aes</span>(<span class="dt">x =</span> RDA1, <span class="dt">y =</span> RDA2)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2"><span class="st">  </span><span class="kw">geom_segment</span>(<span class="dt">data =</span> arrows,<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">0</span>, <span class="dt">y =</span> <span class="dv">0</span>, <span class="dt">xend =</span> RDA1<span class="op">*</span><span class="dv">19</span>, <span class="dt">yend =</span> RDA2<span class="op">*</span><span class="dv">19</span>),<span class="dt">lineend =</span> <span class="st">&quot;round&quot;</span>, <span class="co"># See available arrow types in example above</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">               <span class="dt">linejoin =</span> <span class="st">&quot;round&quot;</span>,</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">               <span class="dt">size =</span> <span class="fl">0.8</span>, </a>
<a class="sourceLine" id="cb55-5" data-line-number="5">               <span class="dt">arrow =</span> <span class="kw">arrow</span>(<span class="dt">length =</span> <span class="kw">unit</span>(<span class="fl">0.15</span>, <span class="st">&quot;inches&quot;</span>)),</a>
<a class="sourceLine" id="cb55-6" data-line-number="6">               <span class="dt">colour =</span> <span class="st">&quot;#7400b8&quot;</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb55-7" data-line-number="7"><span class="st">  </span><span class="kw">geom_label</span>(<span class="dt">data =</span> arrows,<span class="kw">aes</span>(<span class="dt">label =</span> Label, <span class="dt">x =</span> RDA1<span class="op">*</span><span class="dv">21</span>, <span class="dt">y =</span> RDA2<span class="op">*</span><span class="dv">21</span>, <span class="dt">fontface=</span><span class="st">&quot;bold&quot;</span>), <span class="dt">size=</span><span class="dv">6</span>)<span class="op">+</span></a>
<a class="sourceLine" id="cb55-8" data-line-number="8"><span class="st">  </span><span class="kw">coord_fixed</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb55-9" data-line-number="9"><span class="st">  </span><span class="kw">theme</span>(<span class="dt">axis.title.x =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.title.y =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">13</span>),<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">11</span>),<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">vjust=</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb55-10" data-line-number="10"></a>
<a class="sourceLine" id="cb55-11" data-line-number="11"><span class="kw">ggsave</span>(rda.plot2,<span class="dt">filename =</span> <span class="st">&quot;16S_RDA_example2.png&quot;</span>, <span class="dt">width=</span><span class="dv">15</span>, <span class="dt">height=</span><span class="dv">12</span>, <span class="dt">dpi=</span><span class="dv">600</span>)</a></code></pre></div>
<center>
<img src="amplicon_workflow/16S_RDA_example2.png" />
</center>
<div align="center">
Figure 17b: Redundancy Analysis of Clear Cut Soil samples w/ <code>ggplot2</code> Example 2
</div>
<p></br></p>
<p>The first ggplot example does not amplify the biplot axes from our RDA as we see with the RDA created by <code>autoplot()</code>. The second plot looks more like what <code>autplot()</code> produced, which contains axes that were amplified to clearly show the trends. It’s important to be cautious of this type of ordination manipulation because you do not want to “identify” relationships in your data that do not actually exist. That is why I recommend comparing your RDA axes from the RDA <code>summary()</code> (i.e., your site, biplot, and species axes) so that you know exactly how much variation is being described by your environmental variables.</p>
<p>If our RDA had shown these variables as being significant drivers of community composition in the Clear Cut Soil samples, that is what I would describe here. It is also wise to include a table that describes the significance of your RDA or CCA as well as the variation (i.e., adjust R<sup>2</sup> value) explained by your model. However, because the chemical data used for this portion of the workflow is fictional, I won’t describe this figure in depth.</p>
<p>Because none of my environmental variables were significant drivers of community composition, I should <em>not</em> have included them in my RDA. Remember that it’s important to <em>only</em> show environmental variables on your RDAs or CCAs that <strong>significantly</strong> describe the variation in your compositional data that’s explained by your model.</p>
</div>
</div>
<div id="conclusion" class="section level1">
<h1><span class="header-section-number">5</span> Conclusion</h1>
<p>Congratulations, we have reached the end of this workflow! By now you should have some analyses and figures for your data set, and you can start to get to work on interpreting your results. We can do ourselves a favor and save everything in our global environment by running the following line of code. To load this data into your global environment, just run <code>load(&quot;amplicon_WF_environment.Rdata&quot;)</code> in your console, and your global environment will be populated with your data.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">save.image</span>(<span class="st">&quot;amplicon_WF_environment.Rdata&quot;</span>)</a>
<a class="sourceLine" id="cb56-2" data-line-number="2"><span class="co"># to load saved objects/packages/functions, run: load(&quot;amplicon_WF_environment.Rdata&quot;)</span></a></code></pre></div>
<p>Please keep in mind that this is a collection of scripts and analyses that I have created, and this is by no means a Bible for microbial ecology! You do not have to take all of these steps with your own data, and if you have more efficient ways of doing some of these steps, then I encourage you to use those methods. This worfklow is meant to serve as a jumping off point rather than a final destination, so please do whatever you think is necessary to investigate the patterns you’re observing in your microbial communities.</p>
<p>If you’d like to get a hold of me to offer me feedback about this workflow, or if you’d like to discuss more of these steps/programs/stats in depth, do not hestitate to reach out. My contact information is in the <a href="#about-me">About Me</a> section.</p>
<p>Thank you for following along!</p>
</div>
<div id="version-information" class="section level1">
<h1><span class="header-section-number">6</span> Version Information</h1>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="kw">sessionInfo</span>()</a></code></pre></div>
<pre><code>## R version 4.0.5 (2021-03-31)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Big Sur 10.16
## 
## Matrix products: default
## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## loaded via a namespace (and not attached):
##  [1] digest_0.6.27   R6_2.5.1        jsonlite_1.7.2  magrittr_2.0.1  evaluate_0.14  
##  [6] rlang_0.4.11    stringi_1.7.4   jquerylib_0.1.4 bslib_0.3.0     rmarkdown_2.11 
## [11] tools_4.0.5     stringr_1.4.0   xfun_0.26       yaml_2.2.1      fastmap_1.1.0  
## [16] compiler_4.0.5  htmltools_0.5.2 knitr_1.34      sass_0.4.0</code></pre>
</div>
<div id="about-me" class="section level1">
<h1><span class="header-section-number">7</span> About Me</h1>
<p>My name is Hannah and my pronouns are they/them. I am currently a PhD Student at UC Riverside in the <a href="https://ggb.ucr.edu/">Genetics, Genomics, and Bioinformatics</a> PhD program and a member of Dr. Emma Aronson’s lab.</p>
<p>If you have any questions regarding this workflow and the scripts I used, do not hesitate to contact <a href="mailto:hfreu002@ucr.edu?subject=Amplicon%20Workflow">me</a>. Or, if you’d like to talk bioinformatics and all things ’omics, I would love that too!</p>
<div align="center">
<strong>Thank you so much for checking out my workflow!</strong>
</div>
<center>
<a href="https://hlfreund.github.io/"><img src="amplicon_workflow/mylogo.png" alt="website" /></a>
</center>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Andrews">
<p>Andrews, S. n.d. “FastQC: A Quality Control Tool for High Throughput Sequence Data.”</p>
</div>
<div id="ref-Bukin2019">
<p>Bukin, Yu S., Yu P. Galachyants, I. V. Morozov, S. V. Bukin, A. S. Zakharenko, and T. I. Zemskaya. 2019. “The effect of 16s rRNA region choice on bacterial community metabarcoding results.” <em>Scientific Data</em> 6. The Author(s): 1–14. <a href="https://doi.org/10.1038/sdata.2019.7">https://doi.org/10.1038/sdata.2019.7</a>.</p>
</div>
<div id="ref-Bushnell">
<p>Bushnell, Brian. n.d. “BBMap.” <a href="sourceforge.net/projects/bbmap/">sourceforge.net/projects/bbmap/</a>.</p>
</div>
<div id="ref-Callahan2017">
<p>Callahan, Benjamin J., Paul J. McMurdie, and Susan P. Holmes. 2017. “Exact sequence variants should replace operational taxonomic units in marker-gene data analysis.” <em>ISME Journal</em> 11 (12). Nature Publishing Group: 2639–43. <a href="https://doi.org/10.1038/ismej.2017.119">https://doi.org/10.1038/ismej.2017.119</a>.</p>
</div>
<div id="ref-Callahan2016">
<p>Callahan, Benjamin J., Paul J. McMurdie, Michael J. Rosen, Andrew W. Han, Amy Jo A. Johnson, and Susan P. Holmes. 2016. “DADA2: High-resolution sample inference from Illumina amplicon data.” <em>Nature Methods</em> 13 (7). Nature Publishing Group: 581–83. <a href="https://doi.org/10.1038/nmeth.3869">https://doi.org/10.1038/nmeth.3869</a>.</p>
</div>
<div id="ref-Edgar2015">
<p>Edgar, Robert C., and Henrik Flyvbjerg. 2015. “Error filtering, pair assembly and error correction for next-generation sequencing reads.” <em>Bioinformatics</em> 31 (21): 3476–82. <a href="https://doi.org/10.1093/bioinformatics/btv401">https://doi.org/10.1093/bioinformatics/btv401</a>.</p>
</div>
<div id="ref-Gloor2017">
<p>Gloor, Gregory B., Jean M. Macklaim, Vera Pawlowsky-Glahn, and Juan J. Egozcue. 2017. “Microbiome datasets are compositional: And this is not optional.” <em>Frontiers in Microbiology</em> 8 (NOV): 1–6. <a href="https://doi.org/10.3389/fmicb.2017.02224">https://doi.org/10.3389/fmicb.2017.02224</a>.</p>
</div>
<div id="ref-Illumina">
<p>Illumina. n.d. “High-Speed, Multiplexed 16S Microbial Sequencing on the MiSeq System.” <a href="http://files/998/High-Speed, Multiplexed 16S Microbial Sequencing o.pdf">http://files/998/High-Speed, Multiplexed 16S Microbial Sequencing o.pdf</a>.</p>
</div>
<div id="ref-Kassambara2020">
<p>Kassambara, Alboukadel. 2020. “ggpubr: ’ggplot2’ Based Publication Ready Plots.” CRAN. <a href="https://rpkgs.datanovia.com/ggpubr/">https://rpkgs.datanovia.com/ggpubr/</a>.</p>
</div>
<div id="ref-Lahti2019">
<p>Lahti, L, and S Shetty. 2019. “microbiome R package.” Bioconductor. <a href="https://doi.org/10.18129/B9.bioc.microbiome">https://doi.org/10.18129/B9.bioc.microbiome</a>.</p>
</div>
<div id="ref-Lee2019">
<p>Lee, Michael. 2019. “Happy Belly Bioinformatics: an open-source resource dedicated to helping biologists utilize bioinformatics.” <em>Journal of Open Source Education</em> 2 (19): 53. <a href="https://doi.org/10.21105/jose.00053">https://doi.org/10.21105/jose.00053</a>.</p>
</div>
<div id="ref-McMurdie2013">
<p>McMurdie, Paul J., and Susan Holmes. 2013. “Phyloseq: An R Package for Reproducible Interactive Analysis and Graphics of Microbiome Census Data.” <em>PLoS ONE</em> 8 (4). <a href="https://doi.org/10.1371/journal.pone.0061217">https://doi.org/10.1371/journal.pone.0061217</a>.</p>
</div>
<div id="ref-McMurdie2014">
<p>———. 2014. “Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible.” <em>PLoS Computational Biology</em> 10 (4). <a href="https://doi.org/10.1371/journal.pcbi.1003531">https://doi.org/10.1371/journal.pcbi.1003531</a>.</p>
</div>
<div id="ref-Morton2017">
<p>Morton, James T., Liam Toran, Anna Edlund, Jessica L. Metcalf, Christian Lauber, and Rob Knight. 2017. “Uncovering the Horseshoe Effect in Microbial Analyses.” <em>mSystems</em> 2 (1): 1–8. <a href="https://doi.org/10.1128/msystems.00166-16">https://doi.org/10.1128/msystems.00166-16</a>.</p>
</div>
<div id="ref-Oksanen2020">
<p>Oksanen, Jari, F. Guillaume Blanchet, Michael Friendly, Roeland Kindt, Pierre Legendre, Dan McGlinn, Petter R. Minchin, et al. 2020. “vegan: Community Ecology Package.” CRAN. <a href="https://cran.r-project.org/package=vegan">https://cran.r-project.org/package=vegan</a>.</p>
</div>
<div id="ref-Prodan2020">
<p>Prodan, Andrei, Valentina Tremaroli, Harald Brolin, Aeilko H. Zwinderman, Max Nieuwdorp, and Evgeni Levin. 2020. “Comparing bioinformatic pipelines for microbial 16S rRNA amplicon sequencing.” <em>PLoS ONE</em> 15 (1): 1–19. <a href="https://doi.org/10.1371/journal.pone.0227434">https://doi.org/10.1371/journal.pone.0227434</a>.</p>
</div>
<div id="ref-Quinn2019">
<p>Quinn, Thomas P., Ionas Erb, Greg Gloor, Cedric Notredame, Mark F. Richardson, and Tamsyn M. Crowley. 2019. “A field guide for the compositional analysis of any-omics data.” <em>GigaScience</em> 8 (9). Oxford University Press: 1–14. <a href="https://doi.org/10.1093/gigascience/giz107">https://doi.org/10.1093/gigascience/giz107</a>.</p>
</div>
<div id="ref-Quinn2018">
<p>Quinn, Thomas P., Ionas Erb, Mark F. Richardson, and Tamsyn M. Crowley. 2018. “Understanding sequencing data as compositions: An outlook and review.” <em>Bioinformatics</em> 34 (16): 2870–8. <a href="https://doi.org/10.1093/bioinformatics/bty175">https://doi.org/10.1093/bioinformatics/bty175</a>.</p>
</div>
<div id="ref-Rausch2019">
<p>Rausch, Philipp, Malte Rühlemann, Britt M. Hermes, Shauni Doms, Tal Dagan, Katja Dierking, Hanna Domin, et al. 2019. “Comparative analysis of amplicon and metagenomic sequencing methods reveals key features in the evolution of animal metaorganisms.” <em>Microbiome</em> 7 (1). Microbiome: 1–19. <a href="https://doi.org/10.1186/s40168-019-0743-1">https://doi.org/10.1186/s40168-019-0743-1</a>.</p>
</div>
<div id="ref-Rosen2012">
<p>Rosen, Michael J., Benjamin J. Callahan, Daniel S. Fisher, and Susan P. Holmes. 2012. “Denoising PCR-amplified metagenome data.” <em>BMC Bioinformatics</em> 13 (1). <a href="https://doi.org/10.1186/1471-2105-13-283">https://doi.org/10.1186/1471-2105-13-283</a>.</p>
</div>
<div id="ref-Vargas-Albores2017">
<p>Vargas-Albores, Francisco, Luis Enrique Ortiz-Suárez, Enrique Villalpando-Canchola, and Marcel Martínez-Porchas. 2017. “Size-variable zone in V3 region of 16S rRNA.” <em>RNA Biology</em> 14 (11): 1514–21. <a href="https://doi.org/10.1080/15476286.2017.1317912">https://doi.org/10.1080/15476286.2017.1317912</a>.</p>
</div>
<div id="ref-Wang2007">
<p>Wang, Qiong, George M. Garrity, James M. Tiedje, and James R. Cole. 2007. “Naïve Bayesian classifier for rapid assignment of rRNA sequences into the new bacterial taxonomy.” <em>Applied and Environmental Microbiology</em> 73 (16): 5261–7. <a href="https://doi.org/10.1128/AEM.00062-07">https://doi.org/10.1128/AEM.00062-07</a>.</p>
</div>
<div id="ref-Weiss2017">
<p>Weiss, Sophie, Zhenjiang Zech Xu, Shyamal Peddada, Amnon Amir, Kyle Bittinger, Antonio Gonzalez, Catherine Lozupone, et al. 2017. “Normalization and microbial differential abundance strategies depend upon data characteristics.” <em>Microbiome</em> 5 (1). Microbiome: 1–18. <a href="https://doi.org/10.1186/s40168-017-0237-y">https://doi.org/10.1186/s40168-017-0237-y</a>.</p>
</div>
<div id="ref-Wickham2016">
<p>Wickham, Hadley. 2016. “ggplot2: Elegant Graphics for Data Analysis.” Springer-Verlag New York.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
